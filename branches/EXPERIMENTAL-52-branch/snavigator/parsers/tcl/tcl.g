#header
<<
#include <charbuf.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <fcntl.h>

#include "sntoolkit.h"
#undef panic
#define DEBUG	1

#define ZZCOL
//#include "DLexerBase.h"
    // Base info for DLG-generated scanner
//#include "DLGLexer.h"
    // The scanner generated by DLG from this file
//#include "AToken.h"
//typedef ANTLRCommonToken ANTLRToken;

#include "myToken.h"
#include "myPanic.h"
#include "myTokenBuffer.h"
#include "DLGLexer.h"

extern void reset_comment_level();
extern void incr_comment_level();
extern void decr_comment_level();
extern int get_comment_level();

>>

<<

/* It's bad to use globals, we should probably
   rewrite it this as a class and have comment_curly_brace_count
   count as a class member (the way the books tells you).
*/
int comment_curly_brace_count;


void reset_comment_level() {
    comment_curly_brace_count = 0;
}

void incr_comment_level() {
    comment_curly_brace_count++;
}

void decr_comment_level() {
    comment_curly_brace_count--;
}

int get_comment_level() {
    return comment_curly_brace_count;
}


#include "snptools.h"
#undef panic

void fparse_file( FILE *input_file) {

    DLGFileInput in(input_file);

    DLGLexer scanner(&in);

    MyTokenBuffer pipe(&scanner);


    ANTLRToken tok;
    reset_comment_level();
    scanner.mode(DLGLexer::TCL);
    scanner.setToken(&tok);
    scanner.trackColumns();
    TCLParser tclparser(&pipe);
  
    tclparser.init();
    int results;
    // tclparser.program();
    // If we use exceptions:
    tclparser.program(&results);
}

void parse_file(const char *filename) {
    FILE *input_file;

    input_file=fopen(filename,"r");

    if (input_file == NULL) {
        printf("Cannot open (%s) bye\n",filename);
    }
    fparse_file(input_file);
    fclose(input_file);
}

string SN_Symbol::FileName;
SN_Parser_Settings SN_Symbol::DBSettings;

int main(int argc, char **argv)
{
    char *filename;
    char *srcfile=NULL;
    FILE *fnfile;
    size_t n=300;
    char *del;


    sn_set_group("tcl");
    SN_Symbol::DBSettings.sn_process_options(argc, argv);
    filename = (char*) SN_Symbol::DBSettings.GetFilename();
    fnfile=fopen(filename, "r");
    SN_Symbol::DBSettings.sn_init();

    getline(&srcfile,&n,fnfile);
    del = strstr(srcfile, "\n");
    del[0] = 0;
    while ( ! feof(fnfile)) {
      //printf("Filename = %s\n",srcfile);
      SN_Symbol::FileName = srcfile;
      put_file(srcfile, "tcl", NULL);
      parse_file(srcfile);
      // This printf is a marker seen by SN
      // so it knows to update the progress bar.
      printf("%s\n",srcfile);
      fflush(stdout); 
      getline(&srcfile,&n,fnfile);       
      del = strstr(srcfile, "\n");
      if (del!=NULL) {
        del[0] = 0;
      }
    }
    SN_Symbol::DBSettings.sn_close_db();

    return 0;
}

>>




#lexclass TCL

// Note: Tokens commented out exist in TCL syntax, but
// are not currently parsed (basically treated as proc calls).

#token	"[\ \t]+"		<< skip(); >>		/* Leading White */
//#token P_APPEND "append"
//#token P_ARRAY "array"
//#token P_BREAK "break"
//#token P_CONTINUE "continue"
//#token P_DEFAULT "default"
#token P_FOR "for"
#token P_FOREACH "foreach"
#token P_GLOBAL "global"
#token P_IF "if"
#token P_ELSE "else"
#token P_ELSEIF "elseif"
//#token P_INCR "incr"
//#token P_INFO "info"
#token P_LAPPEND "lappend"
#token P_RETURN "return"
#token P_SET "set"
#token P_UNSET "unset"
#token P_WHILE "while"
//#token P_CONCAT "concat"
//#token P_EVAL "eval"
#token P_EXPR "expr"
//#token P_FORMAT "format"
//#token P_GLOB "glob"
//#token P_JOIN "join"
//#token P_LINDEX "lindex"
#token P_LINSERT "linsert"
//#token P_LIST "list"
#token P_LLENGTH "llength"
//#token P_LRANGE "lrange"
//#token P_LREPLACE "lreplace"
//#token P_LSEARCH "lsearch"
//#token P_LSORT  "lsort"
//#token P_REGEXP  "regexp"
//#token P_REGSUB  "regsub"
//#token P_SPLIT "split"
//#token P_STRING "string"
#token P_SWITCH "switch"

#token P_UPLEVEL "uplevel"

//#token P_UPVAR "upvar"
//#token P_WINFO "winfo"
//#token P_ARGS "args"
#token P_BINARY "binary"
#token P_BODY  "body"
#token P_CATCH "catch"
//#token P_EXISTS "exists"
//#token P_FILE "file"
#token P_GETS "gets"
#token P_GLOBLAL "global"
#token P_LSTAT "lstat"
#token P_NAMESPACE "namespace"
#token P_PARRAY "parray"
#token P_PROC "proc"
//#token P_RENAME "rename"
//#token P_SCAN "scan"
#token P_SOURCE "source"
//#token P_STAT "stat"
#token P_TKINFO "tkinfo"
#token P_VARIABLE "variable"
//#token P_VWAIT "vwait"
#token P_CLASS "class"
#token P_COMMON "common"
#token P_CONFIGBODY "configbody"
#token P_CONSTRUCTOR "constructor"
//#token P_DELETE "delete"
#token P_DESTRUCTOR "destructor"
#token P_INHERIT "inherit"
#token P_ISA "isa"
//#token P_ITCL "itcl"
#token P_ITCL_CLASS "itcl_class"
//#token P_ITCL_INFO "itcl_info"
#token P_ITK "itk"
#token P_IWIDGETS "iwidgets"
#token P_LOCAL "local"
#token P_METHOD "method"
//#token P_OBJECT "object"
//#token P_OBJECTS "objects"
//#token P_PREVIOUS "previous"
#token P_PRIVATE "private"
#token P_PROTECTED "protected"
#token P_PUBLIC "public"
//#token P_THIS "this"
#token P_VIRTUAL "virtual"
#token P_NONEWLINE "nonewline"
#token P_THEN "then"
#token P_PUTS "puts"


#token P_EQUALTO "=="
#token P_EQUAL "="
#token P_GTHAN "<"
#token P_GETHAN "<="
#token P_LETHAN ">="
#token P_LTHAN ">"
#token P_NOTEQUALTO "!="
#token P_AND "&&"
#token P_AND2 "&"
#token P_OR "\|\|"
#token P_NOT "!"
#token P_MULT "\*"
#token P_ADD "\+"
#token P_DIV "/"

#token P_SEMI ";"

// These tokens don't have a lot of meaning for us.
#token "[^\|,]" <<skip();>>

/* We need to tell the difference between the following
   variable reference or we could xref the wrong variable:

   % set a "tttt"
   % puts $a 
   tttt
   % set a-s eeee
   eeee
   % puts $a-s
   tttt-s
   % puts ${a-s}
   eeee
   % set -a ssss
   ssss
   % puts $-a
   $-a
   % puts ${-a}
   ssss
   % set a- tttt
   tttt
   % puts $a-
   tttt-
   %  puts "${a} ${a-s} ${-a} ${a-}"
   tttt eeee ssss tttt

*/
#token QUAL "::"
#token "\@" <<skip();>>
#token "?" <<skip();>>
#token "\-\-" <<skip();>>
#token "\\[\ \t]*\n" <<skip();newline();set_endcol(0);>>

#token NEW_LINE "\n"  <<newline();set_endcol(0);>>
#token "\%"  <<skip();>>
#token "'" <<skip();>>
#token IDENT5 "\\~[ \t\n]"
#token ":" <<skip();>>
#token P_UPLEVEL_ABS "uplevel[\ \t]+{\\}#"

#token "#" <<
             more();mode(COMMENT_MODE);>>  // Comments.


#token P_BIND "bind"
//#token BIND_EVENT "<[a-zA-Z_0-9\-][a-zA-Z_0-9\-\ ]*>"

#token P_DOLLAR "\$"
#token "\"" <<mode(LIT_STRING_MODE);more();>>

#token L_CURLY "\{"
#token R_CURLY "\}"

#token L_SQUARE "\["
#token R_SQUARE "\]"

#token L_BRACKET "\("
#token R_BRACKET "\)"

// Ident must appear before FILENAME.
#token QUAL_IDENT "[a-zA-Z.][a-zA-Z_0-9\-.\*&]*::"
#token SOME_OTHER_IDENT "[a-zA-Z.][a-zA-Z_0-9\-.\*&]*:"

#token IDENT1 "[a-zA-Z._&][a-zA-Z_0-9\-.\*&_]*"

#token FILENAME "[a-zA-Z_\~][a-zA-Z_0-9\-.]*"

// We might have an INT or a FLOAT or an IDENT starting
// with a number. 
#token "[0-9]+" <<
                  if (ch == '.' || 
                      (ch >= 'a' && ch <='z') ||
                      (ch >= 'A' && ch <='Z')) {
                    mode(LVALUE_MODE);
                    more();
                  } else {
                    return P_INT;
                  };>>  

#token "\-" <<    
                  if ((ch >= 'a' && ch <='z') ||
                      (ch >= 'A' && ch <='Z')) {
                    mode(LVALUE_MODE);
                    more();
                  } else if (ch >= '0' && ch <='9') {
                    mode(NUMB_MODE);
                    more();
                  } else {
                    return P_SUBTRACT;
                  }>>  

#token IDENT3 "[a-zA-Z.\\][a-zA-Z_0-9\-.\*&]*"

#lexclass LVALUE_MODE
  #token P_DASHGLOB "glob" <<mode(TCL);>>
  #token P_FLOAT ".[0-9]+" <<mode(TCL);>>
  #token P_INT "[0-9]+" <<mode(TCL);>>
  #token IDENT2 "[a-zA-Z_][a-zA-Z_0-9\-.\*&_]*" <<mode(TCL);>>
  #token IDENT4 ".[a-zA-Z_\-.\*&_][a-zA-Z_\-.\*&_]*" <<mode(TCL);>>
  #token IDENT5 "." <<mode(TCL);>>
// End LVALUE_MODE


// Comments are kind of complicated to deal with in tcl
// since things in comment might be match to a command or
// other TCL syntax, for example:
//     set a {
//         puts "hello"
//         # Some code { that had } been commented out }; puts "BAD!"
//  is the same as:
//     set a {
//         puts "hello"
//         # Some code { that had } been commented out
//     }
//     puts "BAD!"
//
// We can work around this by counting the '{' and '}', if the curly
// brace count goes negative then we return R_CURLY (close brace)
// and ignore the comment (kind of like zzskip() had been call).
#lexclass COMMENT_MODE
  #token "\{" <<incr_comment_level();more();>>
  #token "\}" <<decr_comment_level();
                if (get_comment_level()<0) {
                    incr_comment_level();
                    mode(TCL);
                    return R_CURLY;
                } else {more();};>>
  #token "\\[\ \t]*\n" <<more();newline();set_endcol(0);>>
  #token "\n" <<skip();newline();set_endcol(0);mode(TCL);>>
  #token "~[]" <<skip();more();>>
// End COMMENT_MODE

#lexclass NUMB_MODE
  #token "[0-9]+" <<
                  if (ch == '.' || 
                      (ch >= 'a' && ch <='z') ||
                      (ch >= 'A' && ch <='Z')) {
                    mode(LVALUE_MODE);
                    more();
                  } else {
                    mode(TCL);
                    return P_INT;
                  };>>  
  #token "[a-zA-Z]" <<more();mode(LVALUE_MODE);>>
  // Those next two shouldn't be called, but if
  // we where dealing with incorrect code they
  // would helps us cleanly leave NUMB_MODE.
  #token "\n" <<newline();set_endcol(0);skip();mode(TCL);>>
  #token "~[]" <<skip();mode(TCL);>>
// End NUMB_MODE


#tokclass NUMBER {P_INT P_FLOAT}


#lexclass LIT_STRING_MODE
  #token "\\[\"\$\}\{]"  <<more();>>
  #token "\n" <<newline();set_endcol(0);skip();more();>>
  #token LIT_STRING "\"" <<mode(TCL);>>
  #token "\\\\" <<skip();>>
  #token "~[]" <<more();>>
// End LIT_STRING_MODE

#tokclass P_OPERATORS {
             P_EQUALTO P_NOTEQUALTO P_GTHAN P_LTHAN P_GETHAN
             P_LETHAN P_AND P_AND2 P_OR P_NOT P_ADD P_SUBTRACT P_MULT P_DIV}

// They are no reserved words in Tcl.
#tokclass IDENT {IDENT1 IDENT2 IDENT4 IDENT5 P_OPERATORS
                 P_MULT P_DIV P_ADD P_MULT P_VARIABLE P_CLASS
                 P_SUBTRACT  P_NOT P_GTHAN P_LTHAN P_GETHAN
                 P_LETHAN P_SET P_AND2 P_BIND P_PUBLIC P_PROTECTED
                 P_PRIVATE P_INHERIT P_LOCAL P_GLOBAL P_CONSTRUCTOR
                 P_DESTRUCTOR P_METHOD P_EQUALTO IDENT5 P_GETS P_EQUAL
                 P_DASHGLOB SOME_OTHER_IDENT P_PROC P_RETURN /*P_INT P_FLOAT*/}

#tokclass LVALUE {NUMBER IDENT LIT_STRING}

// These are the rsyncronization token classes, used to
// recover from errors.

// Resyncing inside of an ITCL 3.0 class:
#tokclass ITCL30_CLASS_RESYNC {P_CLASS P_METHOD P_PROC P_CONSTRUCTOR P_DESTRUCTOR\
                               P_VARIABLE P_PUBLIC P_PROTECTED P_PRIVATE\
                               P_COMMON}

class TCLParser {
<<

public:
  int Attri;

  int getAttri() {
     return Attri;
  }

  void setAttri(int attri) {
     Attri = attri;
  }

// We can turn off Syntax error reporting by overriding
// the syn method:
/*  void syn(_ANTLRTokenPtr tok, ANTLRChar *egroup,\
             SetWordType *eset, ANTLRTokenType etok, int k){
        // Just ignore syntax errors for now
    };
*/

>>

program :  (stmt|NEW_LINE)+ "@" ;

stmt :
       {QUAL} (QUAL_IDENT)* 
         (
          class_stmt |
          proc_stmt2   |
          source_stmt |
          other_stmts
         )
       (NEW_LINE|P_SEMI)* ;

stmt_block > [int line, int column]:
              L_CURLY (NEW_LINE)* 
                (stmt)*
              endtok:R_CURLY
              <<
                 $line = mytoken($endtok)->getLine();
                 $column = mytoken($endtok)->endcol;
              >>
              ;

proc_stmt[char * scope]: 
            << {
                  SN_Symbol proc;
                  char *id,*qual;
                  int begincol;
                  int endcol;
                  int beginline;
                  int endline;
            >> 

            pr:P_PROC qual_ident > [id,qual,begincol,endcol,beginline]

            <<
              proc.SetIdentifier(id);
              if (scope != NULL) {
                proc.SetClassName(scope);
              }
              proc.SetStartColumn(mytoken($pr)->begcol);
              proc.SetEndColumn(endcol);
              proc.SetStartLine(mytoken($pr)->getLine());
              proc.SetHighlightStartColumn(begincol);
              proc.SetHighlightStartLine(beginline);
              // Well, maybe the StartLine and EndLine might not
              // be on the same line.
              proc.SetHighlightEndLine(beginline);
              proc.SetHighlightEndColumn(endcol);
            >>

            parameters_declr[&proc]

            {
              stmt_block > [endline,endcol]
              <<
                proc.SetEndLine(endline);
                proc.SetEndColumn(endcol);
              >>
            }
            <<proc.SetType(SN_FUNC_DEF);proc.WriteData();}>>
            ; 
proc_stmt2: 
            << {
                  SN_Symbol proc;
                  char *id,*qual;
                  int begincol;
                  int endcol;
                  int beginline;
                  int endline;
            >> 

            pr:P_PROC qual_ident > [id,qual,begincol,endcol,beginline]

            <<
              proc.SetIdentifier(id);
              proc.SetStartColumn(mytoken($pr)->begcol);
              proc.SetEndColumn(endcol);
              proc.SetStartLine(mytoken($pr)->getLine());
              proc.SetHighlightStartColumn(begincol);
              proc.SetHighlightStartLine(beginline);
              // Well, maybe the StartLine and EndLine might not
              // be on the same line.
              proc.SetHighlightEndLine(beginline);
              proc.SetHighlightEndColumn(endcol);
            >>

            parameters_declr[&proc]

            {
              stmt_block > [endline,endcol]
              <<
                proc.SetEndLine(endline);
                proc.SetEndColumn(endcol);
              >>
            }
            <<proc.SetType(SN_FUNC_DEF);proc.WriteData();}>>
            ; 

body_stmt :
             << {
                   SN_Symbol method;
                   char *id;
                   int begincol;
                   int endcol;
                   int beginline;
                   int endline;
                   char* scope = NULL; // we need to extract the scope
                                       // from the qual_ident.
              >> 
              P_BODY qual_ident > [id,scope,begincol,endcol,beginline]
              <<
                   if (scope != NULL) {
                       scope[strlen(scope)-2]='\0';
                       method.SetClassName(scope);
                   }
                   method.SetAttributes(getAttri());
                   method.SetIdentifier(id);
                   method.SetStartColumn(begincol);
                   method.SetEndColumn(endcol);
                   method.SetStartLine(beginline);
                   method.SetHighlightStartColumn(begincol);
                   method.SetHighlightStartLine(beginline);
                   // Well, maybe the StartLine and EndLine might not
                   // be on the same line.
                   method.SetHighlightEndLine(beginline);
                   method.SetHighlightEndColumn(endcol);
                >>

              parameters_declr[&method]
              stmt_block > [endline,endcol]
              <<
                  method.SetEndLine(endline);
                  method.SetEndColumn(endcol);
                  method.SetType(SN_MBR_FUNC_DCL);method.WriteData(); }
              >>
              ;

parameters_declr[SN_Symbol *symbolData]:
                   (
                      L_CURLY 
                        (parameter_declr[$symbolData])*
                      R_CURLY
                    |
                      arg:IDENT
                      <<
                         $symbolData->AddArgumentName(arg->getText());
                      >>
                   );

parameter_declr[SN_Symbol *symbolData] :  
                   arg1:IDENT 
                      <<
                         $symbolData->AddArgumentName(arg1->getText());
                      >>|
                   L_CURLY 
                     arg2:IDENT
                     <<
                         $symbolData->AddArgumentName(arg2->getText());
                     >> 
                     {LVALUE | tcl_list} 
                   R_CURLY;

parameters_declr2 :
                   (
                      L_CURLY 
                        (parameter_declr2)*
                      R_CURLY
                    |
                      arg:IDENT
                   );

parameter_declr2 :  
                   arg1:IDENT |
                   L_CURLY 
                     arg2:IDENT
                     {LVALUE | tcl_list} 
                   R_CURLY;
proc_call :
            (
              var_ref |
              qual_ident |
              embedded_command |
              IDENT3
            )
            {array_index}
            (
              (
                  (stmt_block)?
                |
                  expression
                |
                  P_OPERATOR
              )
              {array_index}
            )*
            ;

class_stmt :  <<
                {
                  SN_Symbol itclclass;
                  char *id,*qual;
                  int begincol;
                  int endcol;
                  int beginline;
                  int endline;
                  setAttri(PAF_PUBLIC);
              >>
              (
                   cl1:P_ITCL_CLASS 
                     qual_ident > [id,qual,begincol,endcol,beginline]
                     <<
                       itclclass.SetIdentifier(id);
                       itclclass.SetStartColumn(mytoken($cl1)->begcol);
                       itclclass.SetEndColumn(endcol);
                       itclclass.SetStartLine(mytoken($cl1)->getLine());
                       itclclass.SetHighlightStartColumn(begincol);
                       itclclass.SetHighlightStartLine(beginline);
                       itclclass.SetHighlightEndLine(beginline);
                       itclclass.SetHighlightEndColumn(endcol);
                     >> 
                     itcl15_declr[id] > [endline,endcol]
                     <<
                       itclclass.SetEndColumn(endcol);
                       itclclass.SetEndLine(endline);
                     >>
                 |
                   cl2:P_CLASS 
                     qual_ident > [id, qual, begincol, endcol, beginline]
                     <<
                       itclclass.SetIdentifier(id);
                       itclclass.SetStartColumn(mytoken($cl2)->begcol);
                       itclclass.SetEndColumn(endcol);
                       itclclass.SetStartLine(mytoken($cl2)->getLine());
                       itclclass.SetHighlightStartColumn(begincol);
                       itclclass.SetHighlightStartLine(beginline);
                       itclclass.SetHighlightEndLine(beginline);
                       itclclass.SetHighlightEndColumn(endcol);
                     >>
                     itcl30_declr[id] > [endline,endcol]
                     <<
                       itclclass.SetEndColumn(endcol);
                       itclclass.SetEndLine(endline);
                     >>

              )
              <<
                itclclass.SetType(SN_CLASS_DEF);itclclass.WriteData();}
              >>
              ;

itcl30_declr[char *scope] > [int line, int column]:
               L_CURLY (NEW_LINE)*
                (
                  itcl30_class_stmts[scope]
                   exception 
                     default: <<
                       
                       $line = LT(1)->getLine();
                       $column = ((ANTLRToken *)LT(1))->endcol;
                       consumeUntil(ITCL30_CLASS_RESYNC_set);
                   >>
                )* 
               rc:R_CURLY 
               <<
                  $line = mytoken($rc)->getLine();
                  $column = mytoken($rc)->endcol;
               >>
               ;

itcl30_class_stmts[char *scope] :
                     (
                       inherit_stmt[scope] |
                       constructor_stmt[scope] |
                       destructor_stmt[scope] |
                       proc_stmt[scope] |
                       common_stmt[scope] |
                       method30_stmt[scope] |
                       secure30_stmt[scope] |
                       variable30_stmt[scope] |
                       other_stmts
                     )
                     (NEW_LINE)*
                     ;

itcl15_declr[char *scope] > [int line, int column] : 
               L_CURLY (NEW_LINE)*
                 (itcl15_class_stmts[scope])*
               rc:R_CURLY
               <<
                  $line = mytoken($rc)->getLine();
                  $column = mytoken($rc)->endcol;
               >>
               ;

itcl15_class_stmts[char *scope] :
                     (
                       inherit_stmt[scope] |
                       constructor_stmt[scope] |
                       destructor_stmt[scope] |
                       method15_stmt[scope] |
                       proc_stmt[scope]  |
                       public15_stmt[scope] |
                       protected15_stmt[scope] |
                       common_stmt[scope] |
                       other_stmts
                     ) 
                     (NEW_LINE)*
                     ;

inherit_stmt[char * scope] : 
            << {
                  SN_Symbol inherit;
                  char *id,*qual;
                  int begincol;
                  int endcol;
                  int beginline;
                  int endline;
            >> 
               P_INHERIT 
               (qual_ident > [id,qual,begincol,endcol,beginline])+
             <<
              inherit.SetIdentifier(id);
              if (scope != NULL) {
                inherit.SetClassName(scope);
              }
              inherit.SetStartColumn(begincol);
              inherit.SetEndColumn(endcol);
              inherit.SetStartLine(beginline);
              inherit.SetHighlightStartColumn(begincol);
              inherit.SetHighlightStartLine(beginline);
              // Well, maybe the StartLine and EndLine might not
              // be on the same line.
              inherit.SetHighlightEndLine(beginline);
              inherit.SetHighlightEndColumn(endcol);
              inherit.SetType(SN_CLASS_INHERIT);inherit.WriteData();}>>
              {";"}
               ;

constructor_stmt[char *scope] :
                   << {
                       SN_Symbol method;
                       char *id;
                       int begincol;
                       int endcol;
                       int beginline;
                       int endline;
                   >> 
                   md:P_CONSTRUCTOR
                   (
                       parameters_declr[&method] 
                     |
                       IDENT
                   )
                   <<
                      if (scope != NULL) {
                          method.SetClassName(scope);
                      }
                      method.SetAttributes(getAttri());
                      method.SetIdentifier(mytoken($md)->getText());
                      method.SetStartColumn(mytoken($md)->begcol);
                      method.SetEndColumn(mytoken($md)->endcol);
                      method.SetStartLine(mytoken($md)->getLine());
                      method.SetHighlightStartColumn(mytoken($md)->begcol);
                      method.SetHighlightStartLine(mytoken($md)->getLine());
                      // Well, maybe the StartLine and EndLine might not
                      // be on the same line.
                      method.SetHighlightEndLine(mytoken($md)->getLine());
                      method.SetHighlightEndColumn(mytoken($md)->endcol);
                   >>
                   (
                       stmt_block {stmt_block}
                     |
                       stmt stmt_block
                   )
                   <<method.SetType(SN_MBR_FUNC_DEF);method.WriteData();}>>
                   {";"}
                   ;

destructor_stmt[char *scope] :
                   << {
                       SN_Symbol method;
                       char *id;
                       int begincol;
                       int endcol;
                       int beginline;
                       int endline;
                   >> 
                   md:P_DESTRUCTOR
                   <<
                      if (scope != NULL) {
                          method.SetClassName(scope);
                      }
                      method.SetAttributes(getAttri());
                      method.SetIdentifier(mytoken($md)->getText());
                      method.SetStartColumn(mytoken($md)->begcol);
                      method.SetEndColumn(mytoken($md)->endcol);
                      method.SetStartLine(mytoken($md)->getLine());
                      method.SetHighlightStartColumn(mytoken($md)->begcol);
                      method.SetHighlightStartLine(mytoken($md)->getLine());
                      // Well, maybe the StartLine and EndLine might not
                      // be on the same line.
                      method.SetHighlightEndLine(mytoken($md)->getLine());
                      method.SetHighlightEndColumn(mytoken($md)->endcol);
                   >>
                   stmt_block
                   {";"}
                   <<method.SetType(SN_MBR_FUNC_DEF);method.WriteData();}>>
                   ;

method15_stmt[char *scope] :
                << {
                    SN_Symbol method;
                    char *id, *qual;
                    int begincol;
                    int endcol;
                    int beginline;
                    int endline;
                    int dclr_type=0;
                >> 
                md:P_METHOD 
                qual_ident > [id,qual,begincol,endcol,beginline]
                <<
                   if (scope != NULL) {
                       method.SetClassName(scope);
                   }
                   method.SetAttributes(getAttri());
                   method.SetIdentifier(id);
                   method.SetStartColumn(mytoken($md)->begcol);
                   method.SetEndColumn(endcol);
                   method.SetStartLine(mytoken($md)->getLine());
                   method.SetHighlightStartColumn(begincol);
                   method.SetHighlightStartLine(beginline);
                   // Well, maybe the StartLine and EndLine might not
                   // be on the same line.
                   method.SetHighlightEndLine(beginline);
                   method.SetHighlightEndColumn(endcol);
                >>
                parameters_declr[&method] 
                stmt_block > [endline,endcol]
                    <<
                       method.SetEndLine(endline);
                       method.SetEndColumn(endcol);
                    >>

                {";"}
                <<
                  method.SetType(SN_MBR_FUNC_DEF);method.WriteData();
                  }
                >>

                ;

method30_stmt[char *scope] :
                << {
                    SN_Symbol method;
                    char *id, *qual;
                    int begincol;
                    int endcol;
                    int beginline;
                    int endline;
                    int dclr_type=0;
                >> 
                md:P_METHOD 
                qual_ident > [id,qual,begincol,endcol,beginline]
                <<
                   if (scope != NULL) {
                       method.SetClassName(scope);
                   }
                   method.SetAttributes(getAttri());
                   method.SetIdentifier(id);
                   method.SetStartColumn(mytoken($md)->begcol);
                   method.SetEndColumn(endcol);
                   method.SetStartLine(mytoken($md)->getLine());
                   method.SetHighlightStartColumn(begincol);
                   method.SetHighlightStartLine(beginline);
                   // Well, maybe the StartLine and EndLine might not
                   // be on the same line.
                   method.SetHighlightEndLine(beginline);
                   method.SetHighlightEndColumn(endcol);
                >>
                {
                  parameters_declr[&method] 
                  {
                    stmt_block > [endline,endcol]
                    <<
                       method.SetEndLine(endline);
                       method.SetEndColumn(endcol);
                       dclr_type=SN_MBR_FUNC_DEF;
                    >>
                  }
                }
                {";"}
                <<if (dclr_type == 0) dclr_type=SN_MBR_FUNC_DCL;
                  method.SetType(dclr_type);method.WriteData(); }>>
                ;

variable30_stmt[char * scope] :
                 << {
                    SN_Symbol vardclr;
                    char *id;
                    int begincol;
                    int endcol;
                    int beginline;
                    int endline;
                 >> 

                 P_VARIABLE
                 var:IDENT 
                 <<
                   vardclr.SetIdentifier(mytoken($var)->getText());
                   if (scope != NULL) {
                     vardclr.SetClassName(scope);
                   }
                   vardclr.SetAttributes(getAttri());
                   vardclr.SetStartColumn(mytoken($var)->begcol);
                   vardclr.SetEndColumn(mytoken($var)->endcol);
                   vardclr.SetStartLine(mytoken($var)->getLine());
                   vardclr.SetHighlightStartColumn(mytoken($var)->begcol);
                   vardclr.SetHighlightStartLine(mytoken($var)->getLine());
                   // Well, maybe the StartLine and EndLine might not
                   // be on the same line.
                   vardclr.SetHighlightEndLine(mytoken($var)->getLine());
                   vardclr.SetHighlightEndColumn(mytoken($var)->endcol);
                 >>
                 {
                   expression 
                   {stmt_block}
                 }
                 <<vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}>>
                 ;

public15_stmt[char * scope] :
               << {
                    SN_Symbol vardclr;
                    char *id;
                    int begincol;
                    int endcol;
                    int beginline;
                    int endline;
                >> 
                P_PUBLIC <<setAttri(PAF_PUBLIC);>>
                var:IDENT
                 <<
                   vardclr.SetIdentifier(mytoken($var)->getText());
                   if (scope != NULL) {
                     vardclr.SetClassName(scope);
                   }
                   vardclr.SetAttributes(getAttri());
                   vardclr.SetStartColumn(mytoken($var)->begcol);
                   vardclr.SetEndColumn(mytoken($var)->endcol);
                   vardclr.SetStartLine(mytoken($var)->getLine());
                   vardclr.SetHighlightStartColumn(mytoken($var)->begcol);
                   vardclr.SetHighlightStartLine(mytoken($var)->getLine());
                   // Well, maybe the StartLine and EndLine might not
                   // be on the same line.
                   vardclr.SetHighlightEndLine(mytoken($var)->getLine());
                   vardclr.SetHighlightEndColumn(mytoken($var)->endcol);
                >>
                {
                  expression
                  {stmt_block}
                }
                {";"}
                 <<vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}>>
                ;

protected15_stmt[char * scope] :
                   << {
                       SN_Symbol vardclr;
                       char *id;
                       int begincol;
                       int endcol;
                       int beginline;
                       int endline;
                   >> 
                   P_PROTECTED <<setAttri(PAF_PROTECTED);>>
                   var:IDENT
                   <<
                     vardclr.SetIdentifier(mytoken($var)->getText());
                     if (scope != NULL) {
                       vardclr.SetClassName(scope);
                     }
                     vardclr.SetAttributes(getAttri());
                     vardclr.SetStartColumn(mytoken($var)->begcol);
                     vardclr.SetEndColumn(mytoken($var)->endcol);
                     vardclr.SetStartLine(mytoken($var)->getLine());
                     vardclr.SetHighlightStartColumn(mytoken($var)->begcol);
                     vardclr.SetHighlightStartLine(mytoken($var)->getLine());
                     // Well, maybe the StartLine and EndLine might not
                     // be on the same line.
                     vardclr.SetHighlightEndLine(mytoken($var)->getLine());
                     vardclr.SetHighlightEndColumn(mytoken($var)->endcol);
                   >>
                   {expression}
                   {";"}
                   <<vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}>>
                   ;

secure30_stmt[char *scope] :
                (
                   P_PUBLIC <<setAttri(PAF_PUBLIC);>> |
                   P_PROTECTED <<setAttri(PAF_PROTECTED);>>|
                   P_PRIVATE <<setAttri(PAF_PRIVATE);>>
                )
                itcl30_secure_cmd[scope] 
                ;

itcl30_secure_cmd[char *scope] :
                    method30_stmt[scope] |
                    proc_stmt[scope] |
                    variable30_stmt[scope] |
                    common_stmt[scope]
                    ;

namespace_stmt :
                 P_NAMESPACE 
                 (
                     namespace_eval_stmt
                   |
                     (expression)+
                 )
                 ;

namespace_eval_stmt :
                      P_EVAL
                      stmt_block
                      ;

eval_stmt :
            P_EVAL
            stmt_block
            ;

common_stmt[char * scope] :
               << {
                 SN_Symbol vardclr;
                 char *id;
                 int begincol;
                 int endcol;
                 int beginline;
                 int endline;
              >> 
              P_COMMON <<setAttri(PAF_COMMON_MBR_VAR_DEF);>>
              var:IDENT
              <<
                vardclr.SetIdentifier(mytoken($var)->getText());
                if (scope != NULL) {
                  vardclr.SetClassName(scope);
                }
                vardclr.SetAttributes(getAttri());
                vardclr.SetStartColumn(mytoken($var)->begcol);
                vardclr.SetEndColumn(mytoken($var)->endcol);
                vardclr.SetStartLine(mytoken($var)->getLine());
                vardclr.SetHighlightStartColumn(mytoken($var)->begcol);
                vardclr.SetHighlightStartLine(mytoken($var)->getLine());
                // Well, maybe the StartLine and EndLine might not
                // be on the same line.
                vardclr.SetHighlightEndLine(mytoken($var)->getLine());
                vardclr.SetHighlightEndColumn(mytoken($var)->endcol);
              >>
              {expression}
              {";"}
              <<vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}>>
              ;
 
expression :
             {QUAL} 
             (
                 LIT_STRING
               |
                 var_ref
               |
                 embedded_command
               |
                 IDENT3
               |
                 NUMBER
               |
                 FILENAME
               |
                 (QUAL_IDENT)*
                 IDENT
               |
                 tcl_list
               |
                 math_expression
             )
             {array_index}
             ;

l_expression :
               {QUAL}
               (
                   var_ref
                 |
                   embedded_command
                 |
                   (QUAL_IDENT)*
                   IDENT
               )
               {array_index}
               ;

embedded_command :
                   L_SQUARE 
                   (
                       stmt
                     |
                       NEW_LINE
                   )*
                   R_SQUARE
                   ;

var_ref :
          P_DOLLAR 
          (
              qual_ident
            |
              L_CURLY
              qual_ident
              R_CURLY 
          )
          ;

tcl_list :
           L_CURLY 
           (NEW_LINE)* 
           (
             (
                 (stmt_block)?
               |
                 expression
               | 
                 sub_expression
             )
             (NEW_LINE)*
           )*
           R_CURLY
           ;

array_index :
              L_BRACKET 
              (expression)+
              R_BRACKET
              ; 

qual_ident > [char *ident,char *qual,int start,int end, int line]:
             {QUAL}
             (
                idA:QUAL_IDENT
                <<$qual = strdup($idA->getText());>>
             )*
             idB:IDENT 
             <<
                $ident = strdup($idB->getText());
                $start = mytoken($idB)->begcol - 1;
                $end = mytoken($idB)->endcol;
                $line = mytoken($idB)->getLine();
              >> 
             ;

other_stmts :  
               set_stmt | 
               unset_stmt | 
               llength_stmt |
               lappend_stmt |
               linsert_stmt |
               list_stmt |
               return_stmt |
               global_stmt |
               expr_stmt |
               puts_stmt |
               proc_call |
               comment_stmt |
               if_stmt |
               switch_stmt |
               foreach_stmt |
               for_stmt |
               uplevel_stmt |
               catch_stmt |
               while_stmt |
               namespace_stmt |
               bind_stmt |
               body_stmt |
               P_SEMI
               ;

rest_of_line :
               (expression)*
               {";"}
               NEW_LINE
               ;

set_stmt :
            P_SET
            l_expression 
            (expression)*
            ;

unset_stmt :
             P_UNSET
             l_expression
             ;

bind_stmt :
            P_BIND
            expression
            {
              BIND_EVENT
              {
                {P_ADD}
                (
                    stmt_block
                  |
                    LIT_STRING
                )
              }
            }
            ;

source_stmt :
              P_SOURCE expression ;

lappend_stmt :
               P_LAPPEND 
               (l_expression | tcl_list) 
               (expression)*
               ;

llength_stmt :
               P_LLENGTH
               (
                 l_expression |
                 tcl_list
               )
               ;

linsert_stmt :
               P_LINSERT
               (
                 l_expression |
                 tcl_list
               ) 
               (
                 NUMBER |
                 l_expression
               )
               (expression)+
               ;

list_stmt :
            P_LIST
            (expression)*
            ;

info_stmt :
            P_INFO
            IDENT
            rest_of_line
            ;

uplevel_stmt :
               (
                 P_UPLEVEL |
                 P_UPLEVEL_ABS
               )
               NUMBER
               (
                 stmt |
                 stmt_block |
                 LIT_STRING
               )
               ;

global_stmt :
              P_GLOBAL 
              (IDENT)*
              ;

return_stmt :
              P_RETURN
              {expression}
              ;

puts_stmt :
            P_PUTS
            {P_NONEWLINE}
            (expression)*
            ;

comment_stmt :
               P_COMMENT 
               ;

catch_stmt :
             P_CATCH
             (
                 (stmt_block)?
               |
                 expression
             )
             {qual_ident}
             ;

if_stmt :
          P_IF 
          (
              L_CURLY
               cond_expression
              R_CURLY
            |
              expression
          ) 
          {P_THEN}
          (
            stmt_block |
            stmt
          )
          (elseif_stmt)* 
          {else_stmt}
          ;

cond_expression :
                  sub_cond_expression;

cond_expression2:
                  (expression | LVALUE)
                  ;

sub_cond_expression :
                      (NEW_LINE)*
                      {P_NOT}
                      (NEW_LINE)*
                      (
                          L_BRACKET
                          (NEW_LINE)*
                          sub_cond_expression
                          (NEW_LINE)*
                          R_BRACKET
                          (NEW_LINE)*
                          (
                            {P_OPERATORS}
                            sub_cond_expression
                          )*
                        |
                          cond_expression2
                          (NEW_LINE)*
                          (
                            {P_OPERATORS}
                            sub_cond_expression
                          )
                      *)
                      ;

elseif_stmt :
              P_ELSEIF 
              (
                  L_CURLY
                  cond_expression
                  R_CURLY
                |
                  expression
              )
              {P_THEN}
              {stmt_block}
              ;

else_stmt :
            P_ELSE
            stmt_block
            ;

switch_stmt : 
              P_SWITCH 
              {P_DASHGLOB}
              expression 
              (
                  L_CURLY
                  switch_body2
                  R_CURLY
                |
                  (switch_case)+
              )
              ;

switch_case :
              expression
              (P_SUBTRACT | stmt_block)
              ;

switch_body2 :
               (NEW_LINE)* 
               (
                 switch_case
                 (NEW_LINE)*
               )+
               ;

foreach_stmt :
               P_FOREACH 
               (l_expression|tcl_list)
               expression
               (
                   (
                     ((l_expression|tcl_list) expression)*
                     (stmt_block|stmt)
                   )?
                 |
                   (stmt_block|stmt)
               )
               ;

for_stmt :
           P_FOR 
           stmt_block 
           L_CURLY 
            cond_expression
           R_CURLY 
           stmt_block
           stmt_block;

while_stmt :
             P_WHILE
             (
                 L_CURLY
                 cond_expression
                 R_CURLY
               |
                 expression
             )
             stmt_block
             ;

expr_stmt :
            P_EXPR
            (
                sub_expression
              |
                L_CURLY
                 {NEW_LINE}
                 sub_expression2
                 ({P_OPERATORS} {NEW_LINE} sub_expression2)*
                R_CURLY
              |
                LIT_STRING
            )
            ;

sub_expression :
                 ( 
                     L_BRACKET 
                      {
                        sub_expression
                        ({P_OPERATORS} sub_expression)*
                      }
                     R_BRACKET 
                   |
                     math_expression
                     ({P_OPERATORS} sub_expression)*
                 )
                 ;

math_expression :
                  var_ref {array_index} |
                  embedded_command |
                  LVALUE |
                  math_function
                  ;

math_function :
                IDENT
                L_BRACKET
                 (sub_expression)*
                R_BRACKET
                ;

sub_expression2 : 
                  (
                      L_BRACKET
                       {NEW_LINE}
                       sub_expression2
                       ({P_OPERATORS} {NEW_LINE} sub_expression2)*
                      R_BRACKET
                      {NEW_LINE}
                    |
                      math_expression2
                      {NEW_LINE}
                      (P_OPERATORS {NEW_LINE} sub_expression2)*
                  )
                  {NEW_LINE}
                  ;

math_expression2 :
                   var_ref {array_index} |
                   embedded_command |
                   math_function2 |
                   LVALUE;

math_function2 :
                 IDENT
                 {NEW_LINE} 
                 L_BRACKET
                 {NEW_LINE}
                 (sub_expression2)*
                 R_BRACKET
                 ;
}
