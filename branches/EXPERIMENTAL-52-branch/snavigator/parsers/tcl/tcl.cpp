/*
 * A n t l r  T r a n s l a t i o n  H e a d e r
 *
 * Terence Parr, Will Cohen, and Hank Dietz: 1989-2001
 * Purdue University Electrical Engineering
 * With AHPCRC, University of Minnesota
 * ANTLR Version 1.33MR33
 *
 *   /home/irox/builds/pccts/bin/antlr -CC -mrhoist off tcl.g
 *
 */

#define ANTLR_VERSION	13333
#include "pcctscfg.h"
#include "pccts_stdio.h"
#include "tokens.h"

#include <charbuf.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <fcntl.h>

#include "sntoolkit.h"
#undef panic
#define DEBUG	1

#define ZZCOL
//#include "DLexerBase.h"
// Base info for DLG-generated scanner
//#include "DLGLexer.h"
// The scanner generated by DLG from this file
//#include "AToken.h"
//typedef ANTLRCommonToken ANTLRToken;

#include "myToken.h"
#include "myPanic.h"
#include "myTokenBuffer.h"
#include "DLGLexer.h"

extern void reset_comment_level();
extern void incr_comment_level();
extern void decr_comment_level();
extern int get_comment_level();

  
#define EXCEPTION_HANDLING
#define NUM_SIGNALS 3
#include "AParser.h"
#include "TCLParser.h"
#include "DLexerBase.h"
#include "ATokPtr.h"

/* MR23 In order to remove calls to PURIFY use the antlr -nopurify option */

#ifndef PCCTS_PURIFY
#define PCCTS_PURIFY(r,s) memset((char *) &(r),'\0',(s));
#endif



/* It's bad to use globals, we should probably
rewrite it this as a class and have comment_curly_brace_count
count as a class member (the way the books tells you).
*/
int comment_curly_brace_count;


void reset_comment_level() {
comment_curly_brace_count = 0;
}

void incr_comment_level() {
comment_curly_brace_count++;
}

void decr_comment_level() {
comment_curly_brace_count--;
}

int get_comment_level() {
return comment_curly_brace_count;
}


#include "snptools.h"
#undef panic

void fparse_file( FILE *input_file) {

    DLGFileInput in(input_file);

    DLGLexer scanner(&in);

    MyTokenBuffer pipe(&scanner);


ANTLRToken tok;
reset_comment_level();
scanner.mode(DLGLexer::TCL);
scanner.setToken(&tok);
scanner.trackColumns();
TCLParser tclparser(&pipe);

    tclparser.init();
int results;
// tclparser.program();
// If we use exceptions:
tclparser.program(&results);
}

void parse_file(const char *filename) {
FILE *input_file;

    input_file=fopen(filename,"r");

    if (input_file == NULL) {
printf("Cannot open (%s) bye\n",filename);
}
fparse_file(input_file);
fclose(input_file);
}

string SN_Symbol::FileName;
SN_Parser_Settings SN_Symbol::DBSettings;

int main(int argc, char **argv)
{
char *filename;
char *srcfile=NULL;
FILE *fnfile;
size_t n=300;
char *del;


sn_set_group("tcl");
SN_Symbol::DBSettings.sn_process_options(argc, argv);
filename = (char*) SN_Symbol::DBSettings.GetFilename();
fnfile=fopen(filename, "r");
SN_Symbol::DBSettings.sn_init();

    getline(&srcfile,&n,fnfile);
del = strstr(srcfile, "\n");
del[0] = 0;
while ( ! feof(fnfile)) {
//printf("Filename = %s\n",srcfile);
SN_Symbol::FileName = srcfile;
put_file(srcfile, "tcl", NULL);
parse_file(srcfile);
// This printf is a marker seen by SN
// so it knows to update the progress bar.
printf("%s\n",srcfile);
fflush(stdout); 
getline(&srcfile,&n,fnfile);       
del = strstr(srcfile, "\n");
if (del!=NULL) {
del[0] = 0;
}
}
SN_Symbol::DBSettings.sn_close_db();

    return 0;
}

  

void TCLParser::
zzdflthandlers( int _signal, int *_retsignal )
{
  *_retsignal = _signal;
}


void
TCLParser::program(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    int zzcnt=1;
    do {
      if ( (setwd1[LA(1)]&0x1) ) {
        stmt(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
        /* MR10 ()+ */ else {
          if ( zzcnt > 1 ) break;
          else {
            if ( guessing ) goto fail;
            if (_sva) _signal=NoViableAlt;
            else _signal=NoSemViableAlt;
            goto _handler;  /* MR7 */
          }
        }
      }
      zzcnt++;
    } while ( 1 );
  }
  zzmatch_wsig(1,_handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd1, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==QUAL) ) {
      zzmatch_wsig(QUAL, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    while ( (LA(1)==QUAL_IDENT) ) {
      zzmatch_wsig(QUAL_IDENT, _handler); consume();
    }
  }
  {
    if ( (setwd1[LA(1)]&0x4) ) {
      class_stmt(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==P_PROC) ) {
        proc_stmt2(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==P_SOURCE) ) {
          source_stmt(&_signal); if (_signal) goto _handler;
        }
        else {
          if ( (setwd1[LA(1)]&0x8) ) {
            other_stmts(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( guessing ) goto fail;
            if (_sva) _signal=NoViableAlt;
            else _signal=NoSemViableAlt;
            goto _handler;  /* MR7 */
          }
        }
      }
    }
  }
  {
    for (;;) {
      if ( !((setwd1[LA(1)]&0x10))) break;
      if ( (LA(1)==NEW_LINE) ) {
        zzmatch_wsig(NEW_LINE, _handler); consume();
      }
      else {
        if ( (LA(1)==P_SEMI) ) {
          zzmatch_wsig(P_SEMI, _handler); consume();
        }
        else break; /* MR6 code for exiting loop "for sure" */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd1, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

TCLParser::_rv3
TCLParser::stmt_block(int *_retsignal)
{
  struct _rv3 _retv;
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr endtok=NULL;
  int _signal=NoSignal;
  PCCTS_PURIFY(_retv,sizeof(struct _rv3))
  *_retsignal = NoSignal;
  zzmatch_wsig(L_CURLY, _handler); consume();
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  {
    while ( (setwd1[LA(1)]&0x40) ) {
      stmt(&_signal); if (_signal) goto _handler;
    }
  }
  zzmatch_wsig(R_CURLY, _handler);
  if ( !guessing ) {
    endtok = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  _retv.line = mytoken( endtok)->getLine();
  _retv.column = mytoken( endtok)->endcol;
  }
 consume();
  return _retv;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd1, 0x80);
  return _retv;
_handler:
  zzdflthandlers(_signal,_retsignal);
  return _retv;
}

void
TCLParser::proc_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr pr=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol proc;
    char *id,*qual;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_PROC, _handler);
  if ( !guessing ) {
    pr = (ANTLRTokenPtr)LT(1);
  }
   consume();
  if ( !guessing ) {
    { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

    id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
  } else {
    qual_ident(&_signal);
  }
  if ( !guessing ) {
  
  proc.SetIdentifier(id);
  if (scope != NULL) {
    proc.SetClassName(scope);
  }
  proc.SetStartColumn(mytoken( pr)->begcol);
  proc.SetEndColumn(endcol);
  proc.SetStartLine(mytoken( pr)->getLine());
  proc.SetHighlightStartColumn(begincol);
  proc.SetHighlightStartLine(beginline);
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  proc.SetHighlightEndLine(beginline);
  proc.SetHighlightEndColumn(endcol);
  }
  parameters_declr(&_signal, &proc ); if (_signal) goto _handler;
  {
    if ( (LA(1)==L_CURLY) ) {
      if ( !guessing ) {
        { struct _rv3 _trv; _trv = stmt_block(&_signal); if (_signal) goto _handler;

        endline = _trv.line; endcol  = _trv.column; }
      } else {
        stmt_block(&_signal);
      }
      if ( !guessing ) {
      
      proc.SetEndLine(endline);
      proc.SetEndColumn(endcol);
      }
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  proc.SetType(SN_FUNC_DEF);proc.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd2, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::proc_stmt2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr pr=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol proc;
    char *id,*qual;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_PROC, _handler);
  if ( !guessing ) {
    pr = (ANTLRTokenPtr)LT(1);
  }
   consume();
  if ( !guessing ) {
    { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

    id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
  } else {
    qual_ident(&_signal);
  }
  if ( !guessing ) {
  
  proc.SetIdentifier(id);
  proc.SetStartColumn(mytoken( pr)->begcol);
  proc.SetEndColumn(endcol);
  proc.SetStartLine(mytoken( pr)->getLine());
  proc.SetHighlightStartColumn(begincol);
  proc.SetHighlightStartLine(beginline);
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  proc.SetHighlightEndLine(beginline);
  proc.SetHighlightEndColumn(endcol);
  }
  parameters_declr(&_signal, &proc ); if (_signal) goto _handler;
  {
    if ( (LA(1)==L_CURLY) ) {
      if ( !guessing ) {
        { struct _rv3 _trv; _trv = stmt_block(&_signal); if (_signal) goto _handler;

        endline = _trv.line; endcol  = _trv.column; }
      } else {
        stmt_block(&_signal);
      }
      if ( !guessing ) {
      
      proc.SetEndLine(endline);
      proc.SetEndColumn(endcol);
      }
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  proc.SetType(SN_FUNC_DEF);proc.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd2, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::body_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol method;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
    char* scope = NULL; // we need to extract the scope
    // from the qual_ident.
  zzmatch_wsig(P_BODY, _handler); consume();
  if ( !guessing ) {
    { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

    id = _trv.ident; scope = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
  } else {
    qual_ident(&_signal);
  }
  if ( !guessing ) {
  
  if (scope != NULL) {
    scope[strlen(scope)-2]='\0';
    method.SetClassName(scope);
  }
  method.SetAttributes(getAttri());
  method.SetIdentifier(id);
  method.SetStartColumn(begincol);
  method.SetEndColumn(endcol);
  method.SetStartLine(beginline);
  method.SetHighlightStartColumn(begincol);
  method.SetHighlightStartLine(beginline);
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  method.SetHighlightEndLine(beginline);
  method.SetHighlightEndColumn(endcol);
  }
  parameters_declr(&_signal, &method ); if (_signal) goto _handler;
  if ( !guessing ) {
    { struct _rv3 _trv; _trv = stmt_block(&_signal); if (_signal) goto _handler;

    endline = _trv.line; endcol  = _trv.column; }
  } else {
    stmt_block(&_signal);
  }
  if ( !guessing ) {
  
  method.SetEndLine(endline);
  method.SetEndColumn(endcol);
  method.SetType(SN_MBR_FUNC_DCL);method.WriteData(); }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd2, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::parameters_declr(int *_retsignal,SN_Symbol * symbolData)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr arg=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      {
        while ( (setwd2[LA(1)]&0x8) ) {
          parameter_declr(&_signal,  symbolData ); if (_signal) goto _handler;
        }
      }
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( (setwd2[LA(1)]&0x10) ) {
        zzsetmatch_wsig(IDENT_set, _handler);
        if ( !guessing ) {
                arg = (ANTLRTokenPtr)LT(1);
        }
        
        if ( !guessing ) {
        
        symbolData->AddArgumentName(arg->getText());
        }
 consume();
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd2, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::parameter_declr(int *_retsignal,SN_Symbol * symbolData)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr arg1=NULL, arg2=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  if ( (setwd2[LA(1)]&0x40) ) {
    zzsetmatch_wsig(IDENT_set, _handler);
    if ( !guessing ) {
        arg1 = (ANTLRTokenPtr)LT(1);
    }
    
    if ( !guessing ) {
    
    symbolData->AddArgumentName(arg1->getText());
    }
 consume();
  }
  else {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      zzsetmatch_wsig(IDENT_set, _handler);
      if ( !guessing ) {
            arg2 = (ANTLRTokenPtr)LT(1);
      }
      
      if ( !guessing ) {
      
      symbolData->AddArgumentName(arg2->getText());
      }
 consume();
      {
        if ( (setwd2[LA(1)]&0x80) ) {
          zzsetmatch_wsig(LVALUE_set, _handler); consume();
        }
        else {
          if ( (LA(1)==L_CURLY) ) {
            tcl_list(&_signal); if (_signal) goto _handler;
          }
          /* MR23 skip error clause for {...} when exceptions in use */
        }
      }
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( guessing ) goto fail;
      if (_sva) _signal=NoViableAlt;
      else _signal=NoSemViableAlt;
      goto _handler;  /* MR7 */
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd3, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::parameters_declr2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr arg=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      {
        while ( (setwd3[LA(1)]&0x2) ) {
          parameter_declr2(&_signal); if (_signal) goto _handler;
        }
      }
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( (setwd3[LA(1)]&0x4) ) {
        zzsetmatch_wsig(IDENT_set, _handler);
        if ( !guessing ) {
                arg = (ANTLRTokenPtr)LT(1);
        }
         consume();
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd3, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::parameter_declr2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr arg1=NULL, arg2=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  if ( (setwd3[LA(1)]&0x10) ) {
    zzsetmatch_wsig(IDENT_set, _handler);
    if ( !guessing ) {
        arg1 = (ANTLRTokenPtr)LT(1);
    }
     consume();
  }
  else {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      zzsetmatch_wsig(IDENT_set, _handler);
      if ( !guessing ) {
            arg2 = (ANTLRTokenPtr)LT(1);
      }
       consume();
      {
        if ( (setwd3[LA(1)]&0x20) ) {
          zzsetmatch_wsig(LVALUE_set, _handler); consume();
        }
        else {
          if ( (LA(1)==L_CURLY) ) {
            tcl_list(&_signal); if (_signal) goto _handler;
          }
          /* MR23 skip error clause for {...} when exceptions in use */
        }
      }
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( guessing ) goto fail;
      if (_sva) _signal=NoViableAlt;
      else _signal=NoSemViableAlt;
      goto _handler;  /* MR7 */
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd3, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::proc_call(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==P_DOLLAR) ) {
      var_ref(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (setwd3[LA(1)]&0x80) ) {
        qual_ident(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==L_SQUARE) ) {
          embedded_command(&_signal); if (_signal) goto _handler;
        }
        else {
          if ( (LA(1)==IDENT3) ) {
            zzmatch_wsig(IDENT3, _handler); consume();
          }
          else {
            if ( guessing ) goto fail;
            if (_sva) _signal=NoViableAlt;
            else _signal=NoSemViableAlt;
            goto _handler;  /* MR7 */
          }
        }
      }
    }
  }
  {
    if ( (LA(1)==L_BRACKET) ) {
      array_index(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    while ( (setwd4[LA(1)]&0x1) ) {
      {
        zzGUESS_BLOCK
        zzGUESS
        if ( !zzrv && (LA(1)==L_CURLY) ) {
          {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
          zzGUESS_DONE
          {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
        }
        else {
          if ( !zzrv ) zzGUESS_DONE;
          if ( (setwd4[LA(1)]&0x2) ) {
            expression(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( !zzrv ) zzGUESS_DONE;
            if ( (LA(1)==P_OPERATOR) ) {
              zzmatch_wsig(P_OPERATOR, _handler); consume();
            }
            else {
              if ( guessing ) goto fail;
              if (_sva) _signal=NoViableAlt;
              else _signal=NoSemViableAlt;
              goto _handler;  /* MR7 */
            }
          }
        }
      }
      {
        if ( (LA(1)==L_BRACKET) ) {
          array_index(&_signal); if (_signal) goto _handler;
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd4, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::class_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr cl1=NULL, cl2=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  
  {
    SN_Symbol itclclass;
    char *id,*qual;
    int begincol;
    int endcol;
    int beginline;
    int endline;
    setAttri(PAF_PUBLIC);
  {
    if ( (LA(1)==P_ITCL_CLASS) ) {
      zzmatch_wsig(P_ITCL_CLASS, _handler);
      if ( !guessing ) {
            cl1 = (ANTLRTokenPtr)LT(1);
      }
       consume();
      if ( !guessing ) {
        { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

        id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
      } else {
        qual_ident(&_signal);
      }
      if ( !guessing ) {
      
      itclclass.SetIdentifier(id);
      itclclass.SetStartColumn(mytoken( cl1)->begcol);
      itclclass.SetEndColumn(endcol);
      itclclass.SetStartLine(mytoken( cl1)->getLine());
      itclclass.SetHighlightStartColumn(begincol);
      itclclass.SetHighlightStartLine(beginline);
      itclclass.SetHighlightEndLine(beginline);
      itclclass.SetHighlightEndColumn(endcol);
      }
      if ( !guessing ) {
        { struct _rv15 _trv; _trv = itcl15_declr(&_signal, id ); if (_signal) goto _handler;

        endline = _trv.line; endcol  = _trv.column; }
      } else {
        itcl15_declr(&_signal, id );
      }
      if ( !guessing ) {
      
      itclclass.SetEndColumn(endcol);
      itclclass.SetEndLine(endline);
      }
    }
    else {
      if ( (LA(1)==P_CLASS) ) {
        zzmatch_wsig(P_CLASS, _handler);
        if ( !guessing ) {
                cl2 = (ANTLRTokenPtr)LT(1);
        }
         consume();
        if ( !guessing ) {
          { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

          id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
        } else {
          qual_ident(&_signal);
        }
        if ( !guessing ) {
        
        itclclass.SetIdentifier(id);
        itclclass.SetStartColumn(mytoken( cl2)->begcol);
        itclclass.SetEndColumn(endcol);
        itclclass.SetStartLine(mytoken( cl2)->getLine());
        itclclass.SetHighlightStartColumn(begincol);
        itclclass.SetHighlightStartLine(beginline);
        itclclass.SetHighlightEndLine(beginline);
        itclclass.SetHighlightEndColumn(endcol);
        }
        if ( !guessing ) {
          { struct _rv13 _trv; _trv = itcl30_declr(&_signal, id ); if (_signal) goto _handler;

          endline = _trv.line; endcol  = _trv.column; }
        } else {
          itcl30_declr(&_signal, id );
        }
        if ( !guessing ) {
        
        itclclass.SetEndColumn(endcol);
        itclclass.SetEndLine(endline);
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  if ( !guessing ) {
  
  itclclass.SetType(SN_CLASS_DEF);itclclass.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd4, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

TCLParser::_rv13
TCLParser::itcl30_declr(int *_retsignal,char * scope)
{
  struct _rv13 _retv;
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr rc=NULL;
  int _signal=NoSignal;
  PCCTS_PURIFY(_retv,sizeof(struct _rv13))
  *_retsignal = NoSignal;
  zzmatch_wsig(L_CURLY, _handler); consume();
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _blk37_alt1_handler); consume();
    }
  }
  {
    while ( (setwd4[LA(1)]&0x10) ) {
      itcl30_class_stmts(&_signal, scope ); if (_signal) goto _blk37_alt1_handler;
    }
  }
  zzmatch_wsig(R_CURLY, _blk37_alt1_handler);
  if ( !guessing ) {
    rc = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  _retv.line = mytoken( rc)->getLine();
  _retv.column = mytoken( rc)->endcol;
  }
 consume();
  return _retv;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd4, 0x20);
  return _retv;
  /* exception handlers */
_blk37_alt1_handler:
  switch ( _signal ) {
  case NoSignal: break;  /* MR7 */
  default :
    
    
                       _retv.line = LT(1)->getLine();
    _retv.column = ((ANTLRToken *)LT(1))->endcol;
    consumeUntil(ITCL30_CLASS_RESYNC_set);
    _signal=NoSignal;  /* MR7 */
    break;  /* MR7 */
  }
  goto _handler;  /* MR7 */
_handler:
  zzdflthandlers(_signal,_retsignal);
  return _retv;
}

void
TCLParser::itcl30_class_stmts(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==P_INHERIT) ) {
      inherit_stmt(&_signal, scope ); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==P_CONSTRUCTOR) ) {
        constructor_stmt(&_signal, scope ); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==P_DESTRUCTOR) ) {
          destructor_stmt(&_signal, scope ); if (_signal) goto _handler;
        }
        else {
          if ( (LA(1)==P_PROC) ) {
            proc_stmt(&_signal, scope ); if (_signal) goto _handler;
          }
          else {
            if ( (LA(1)==P_COMMON) ) {
              common_stmt(&_signal, scope ); if (_signal) goto _handler;
            }
            else {
              if ( (LA(1)==P_METHOD) ) {
                method30_stmt(&_signal, scope ); if (_signal) goto _handler;
              }
              else {
                if ( (setwd4[LA(1)]&0x40) ) {
                  secure30_stmt(&_signal, scope ); if (_signal) goto _handler;
                }
                else {
                  if ( (LA(1)==P_VARIABLE) ) {
                    variable30_stmt(&_signal, scope ); if (_signal) goto _handler;
                  }
                  else {
                    if ( (setwd4[LA(1)]&0x80) ) {
                      other_stmts(&_signal); if (_signal) goto _handler;
                    }
                    else {
                      if ( guessing ) goto fail;
                      if (_sva) _signal=NoViableAlt;
                      else _signal=NoSemViableAlt;
                      goto _handler;  /* MR7 */
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd5, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

TCLParser::_rv15
TCLParser::itcl15_declr(int *_retsignal,char * scope)
{
  struct _rv15 _retv;
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr rc=NULL;
  int _signal=NoSignal;
  PCCTS_PURIFY(_retv,sizeof(struct _rv15))
  *_retsignal = NoSignal;
  zzmatch_wsig(L_CURLY, _handler); consume();
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  {
    while ( (setwd5[LA(1)]&0x2) ) {
      itcl15_class_stmts(&_signal, scope ); if (_signal) goto _handler;
    }
  }
  zzmatch_wsig(R_CURLY, _handler);
  if ( !guessing ) {
    rc = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  _retv.line = mytoken( rc)->getLine();
  _retv.column = mytoken( rc)->endcol;
  }
 consume();
  return _retv;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd5, 0x4);
  return _retv;
_handler:
  zzdflthandlers(_signal,_retsignal);
  return _retv;
}

void
TCLParser::itcl15_class_stmts(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==P_INHERIT) ) {
      inherit_stmt(&_signal, scope ); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==P_CONSTRUCTOR) ) {
        constructor_stmt(&_signal, scope ); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==P_DESTRUCTOR) ) {
          destructor_stmt(&_signal, scope ); if (_signal) goto _handler;
        }
        else {
          if ( (LA(1)==P_METHOD) ) {
            method15_stmt(&_signal, scope ); if (_signal) goto _handler;
          }
          else {
            if ( (LA(1)==P_PROC) ) {
              proc_stmt(&_signal, scope ); if (_signal) goto _handler;
            }
            else {
              if ( (LA(1)==P_PUBLIC) ) {
                public15_stmt(&_signal, scope ); if (_signal) goto _handler;
              }
              else {
                if ( (LA(1)==P_PROTECTED) ) {
                  protected15_stmt(&_signal, scope ); if (_signal) goto _handler;
                }
                else {
                  if ( (LA(1)==P_COMMON) ) {
                    common_stmt(&_signal, scope ); if (_signal) goto _handler;
                  }
                  else {
                    if ( (setwd5[LA(1)]&0x8) ) {
                      other_stmts(&_signal); if (_signal) goto _handler;
                    }
                    else {
                      if ( guessing ) goto fail;
                      if (_sva) _signal=NoViableAlt;
                      else _signal=NoSemViableAlt;
                      goto _handler;  /* MR7 */
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd5, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::inherit_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol inherit;
    char *id,*qual;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_INHERIT, _handler); consume();
  {
    int zzcnt=1;
    do {
      if ( !guessing ) {
        { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

        id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
      } else {
        qual_ident(&_signal);
      }
    } while ( (setwd5[LA(1)]&0x20) );
  }
  if ( !guessing ) {
  
  inherit.SetIdentifier(id);
  if (scope != NULL) {
    inherit.SetClassName(scope);
  }
  inherit.SetStartColumn(begincol);
  inherit.SetEndColumn(endcol);
  inherit.SetStartLine(beginline);
  inherit.SetHighlightStartColumn(begincol);
  inherit.SetHighlightStartLine(beginline);
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  inherit.SetHighlightEndLine(beginline);
  inherit.SetHighlightEndColumn(endcol);
  inherit.SetType(SN_CLASS_INHERIT);inherit.WriteData();}
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd5, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::constructor_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr md=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol method;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_CONSTRUCTOR, _handler);
  if ( !guessing ) {
    md = (ANTLRTokenPtr)LT(1);
  }
   consume();
  {
    if ( (setwd5[LA(1)]&0x80) ) {
      parameters_declr(&_signal, &method ); if (_signal) goto _handler;
    }
    else {
      if ( (setwd6[LA(1)]&0x1) ) {
        zzsetmatch_wsig(IDENT_set, _handler); consume();
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  if ( !guessing ) {
  
  if (scope != NULL) {
    method.SetClassName(scope);
  }
  method.SetAttributes(getAttri());
  method.SetIdentifier(mytoken( md)->getText());
  method.SetStartColumn(mytoken( md)->begcol);
  method.SetEndColumn(mytoken( md)->endcol);
  method.SetStartLine(mytoken( md)->getLine());
  method.SetHighlightStartColumn(mytoken( md)->begcol);
  method.SetHighlightStartLine(mytoken( md)->getLine());
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  method.SetHighlightEndLine(mytoken( md)->getLine());
  method.SetHighlightEndColumn(mytoken( md)->endcol);
  }
  {
    if ( (LA(1)==L_CURLY) ) {
      stmt_block(&_signal); if (_signal) goto _handler;
      {
        if ( (LA(1)==L_CURLY) ) {
          stmt_block(&_signal); if (_signal) goto _handler;
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
    else {
      if ( (setwd6[LA(1)]&0x2) ) {
        stmt(&_signal); if (_signal) goto _handler;
        stmt_block(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  if ( !guessing ) {
  method.SetType(SN_MBR_FUNC_DEF);method.WriteData();}
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd6, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::destructor_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr md=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol method;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_DESTRUCTOR, _handler);
  if ( !guessing ) {
    md = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  if (scope != NULL) {
    method.SetClassName(scope);
  }
  method.SetAttributes(getAttri());
  method.SetIdentifier(mytoken( md)->getText());
  method.SetStartColumn(mytoken( md)->begcol);
  method.SetEndColumn(mytoken( md)->endcol);
  method.SetStartLine(mytoken( md)->getLine());
  method.SetHighlightStartColumn(mytoken( md)->begcol);
  method.SetHighlightStartLine(mytoken( md)->getLine());
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  method.SetHighlightEndLine(mytoken( md)->getLine());
  method.SetHighlightEndColumn(mytoken( md)->endcol);
  }
 consume();
  stmt_block(&_signal); if (_signal) goto _handler;
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  method.SetType(SN_MBR_FUNC_DEF);method.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd6, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::method15_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr md=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol method;
    char *id, *qual;
    int begincol;
    int endcol;
    int beginline;
    int endline;
    int dclr_type=0;
  zzmatch_wsig(P_METHOD, _handler);
  if ( !guessing ) {
    md = (ANTLRTokenPtr)LT(1);
  }
   consume();
  if ( !guessing ) {
    { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

    id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
  } else {
    qual_ident(&_signal);
  }
  if ( !guessing ) {
  
  if (scope != NULL) {
    method.SetClassName(scope);
  }
  method.SetAttributes(getAttri());
  method.SetIdentifier(id);
  method.SetStartColumn(mytoken( md)->begcol);
  method.SetEndColumn(endcol);
  method.SetStartLine(mytoken( md)->getLine());
  method.SetHighlightStartColumn(begincol);
  method.SetHighlightStartLine(beginline);
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  method.SetHighlightEndLine(beginline);
  method.SetHighlightEndColumn(endcol);
  }
  parameters_declr(&_signal, &method ); if (_signal) goto _handler;
  if ( !guessing ) {
    { struct _rv3 _trv; _trv = stmt_block(&_signal); if (_signal) goto _handler;

    endline = _trv.line; endcol  = _trv.column; }
  } else {
    stmt_block(&_signal);
  }
  if ( !guessing ) {
  
  method.SetEndLine(endline);
  method.SetEndColumn(endcol);
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  
  method.SetType(SN_MBR_FUNC_DEF);method.WriteData();
}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd6, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::method30_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr md=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol method;
    char *id, *qual;
    int begincol;
    int endcol;
    int beginline;
    int endline;
    int dclr_type=0;
  zzmatch_wsig(P_METHOD, _handler);
  if ( !guessing ) {
    md = (ANTLRTokenPtr)LT(1);
  }
   consume();
  if ( !guessing ) {
    { struct _rv37 _trv; _trv = qual_ident(&_signal); if (_signal) goto _handler;

    id = _trv.ident; qual = _trv.qual; begincol = _trv.start; endcol = _trv.end; beginline  = _trv.line; }
  } else {
    qual_ident(&_signal);
  }
  if ( !guessing ) {
  
  if (scope != NULL) {
    method.SetClassName(scope);
  }
  method.SetAttributes(getAttri());
  method.SetIdentifier(id);
  method.SetStartColumn(mytoken( md)->begcol);
  method.SetEndColumn(endcol);
  method.SetStartLine(mytoken( md)->getLine());
  method.SetHighlightStartColumn(begincol);
  method.SetHighlightStartLine(beginline);
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  method.SetHighlightEndLine(beginline);
  method.SetHighlightEndColumn(endcol);
  }
  {
    if ( (setwd6[LA(1)]&0x20) ) {
      parameters_declr(&_signal, &method ); if (_signal) goto _handler;
      {
        if ( (LA(1)==L_CURLY) ) {
          if ( !guessing ) {
            { struct _rv3 _trv; _trv = stmt_block(&_signal); if (_signal) goto _handler;

            endline = _trv.line; endcol  = _trv.column; }
          } else {
            stmt_block(&_signal);
          }
          if ( !guessing ) {
          
          method.SetEndLine(endline);
          method.SetEndColumn(endcol);
          dclr_type=SN_MBR_FUNC_DEF;
          }
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  if (dclr_type == 0) dclr_type=SN_MBR_FUNC_DCL;
  method.SetType(dclr_type);method.WriteData(); }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd6, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::variable30_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr var=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol vardclr;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_VARIABLE, _handler); consume();
  zzsetmatch_wsig(IDENT_set, _handler);
  if ( !guessing ) {
    var = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  vardclr.SetIdentifier(mytoken( var)->getText());
  if (scope != NULL) {
    vardclr.SetClassName(scope);
  }
  vardclr.SetAttributes(getAttri());
  vardclr.SetStartColumn(mytoken( var)->begcol);
  vardclr.SetEndColumn(mytoken( var)->endcol);
  vardclr.SetStartLine(mytoken( var)->getLine());
  vardclr.SetHighlightStartColumn(mytoken( var)->begcol);
  vardclr.SetHighlightStartLine(mytoken( var)->getLine());
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  vardclr.SetHighlightEndLine(mytoken( var)->getLine());
  vardclr.SetHighlightEndColumn(mytoken( var)->endcol);
  }
 consume();
  {
    if ( (setwd6[LA(1)]&0x80) ) {
      expression(&_signal); if (_signal) goto _handler;
      {
        if ( (LA(1)==L_CURLY) ) {
          stmt_block(&_signal); if (_signal) goto _handler;
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd7, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::public15_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr var=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol vardclr;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_PUBLIC, _handler);
  if ( !guessing ) {
  setAttri(PAF_PUBLIC);
  }
 consume();
  zzsetmatch_wsig(IDENT_set, _handler);
  if ( !guessing ) {
    var = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  vardclr.SetIdentifier(mytoken( var)->getText());
  if (scope != NULL) {
    vardclr.SetClassName(scope);
  }
  vardclr.SetAttributes(getAttri());
  vardclr.SetStartColumn(mytoken( var)->begcol);
  vardclr.SetEndColumn(mytoken( var)->endcol);
  vardclr.SetStartLine(mytoken( var)->getLine());
  vardclr.SetHighlightStartColumn(mytoken( var)->begcol);
  vardclr.SetHighlightStartLine(mytoken( var)->getLine());
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  vardclr.SetHighlightEndLine(mytoken( var)->getLine());
  vardclr.SetHighlightEndColumn(mytoken( var)->endcol);
  }
 consume();
  {
    if ( (setwd7[LA(1)]&0x2) ) {
      expression(&_signal); if (_signal) goto _handler;
      {
        if ( (LA(1)==L_CURLY) ) {
          stmt_block(&_signal); if (_signal) goto _handler;
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd7, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::protected15_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr var=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol vardclr;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_PROTECTED, _handler);
  if ( !guessing ) {
  setAttri(PAF_PROTECTED);
  }
 consume();
  zzsetmatch_wsig(IDENT_set, _handler);
  if ( !guessing ) {
    var = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  vardclr.SetIdentifier(mytoken( var)->getText());
  if (scope != NULL) {
    vardclr.SetClassName(scope);
  }
  vardclr.SetAttributes(getAttri());
  vardclr.SetStartColumn(mytoken( var)->begcol);
  vardclr.SetEndColumn(mytoken( var)->endcol);
  vardclr.SetStartLine(mytoken( var)->getLine());
  vardclr.SetHighlightStartColumn(mytoken( var)->begcol);
  vardclr.SetHighlightStartLine(mytoken( var)->getLine());
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  vardclr.SetHighlightEndLine(mytoken( var)->getLine());
  vardclr.SetHighlightEndColumn(mytoken( var)->endcol);
  }
 consume();
  {
    if ( (setwd7[LA(1)]&0x8) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd7, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::secure30_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==P_PUBLIC) ) {
      zzmatch_wsig(P_PUBLIC, _handler);
      if ( !guessing ) {
      setAttri(PAF_PUBLIC);
      }
 consume();
    }
    else {
      if ( (LA(1)==P_PROTECTED) ) {
        zzmatch_wsig(P_PROTECTED, _handler);
        if ( !guessing ) {
        setAttri(PAF_PROTECTED);
        }
 consume();
      }
      else {
        if ( (LA(1)==P_PRIVATE) ) {
          zzmatch_wsig(P_PRIVATE, _handler);
          if ( !guessing ) {
          setAttri(PAF_PRIVATE);
          }
 consume();
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  itcl30_secure_cmd(&_signal, scope ); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd7, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::itcl30_secure_cmd(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  if ( (LA(1)==P_METHOD) ) {
    method30_stmt(&_signal, scope ); if (_signal) goto _handler;
  }
  else {
    if ( (LA(1)==P_PROC) ) {
      proc_stmt(&_signal, scope ); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==P_VARIABLE) ) {
        variable30_stmt(&_signal, scope ); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==P_COMMON) ) {
          common_stmt(&_signal, scope ); if (_signal) goto _handler;
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd7, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::namespace_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_NAMESPACE, _handler); consume();
  {
    if ( (LA(1)==P_EVAL) ) {
      namespace_eval_stmt(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (setwd7[LA(1)]&0x80) ) {
        {
          int zzcnt=1;
          do {
            expression(&_signal); if (_signal) goto _handler;
          } while ( (setwd8[LA(1)]&0x1) );
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd8, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::namespace_eval_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_EVAL, _handler); consume();
  stmt_block(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd8, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::eval_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_EVAL, _handler); consume();
  stmt_block(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd8, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::common_stmt(int *_retsignal,char * scope)
{
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr var=NULL;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    SN_Symbol vardclr;
    char *id;
    int begincol;
    int endcol;
    int beginline;
    int endline;
  zzmatch_wsig(P_COMMON, _handler);
  if ( !guessing ) {
  setAttri(PAF_COMMON_MBR_VAR_DEF);
  }
 consume();
  zzsetmatch_wsig(IDENT_set, _handler);
  if ( !guessing ) {
    var = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  vardclr.SetIdentifier(mytoken( var)->getText());
  if (scope != NULL) {
    vardclr.SetClassName(scope);
  }
  vardclr.SetAttributes(getAttri());
  vardclr.SetStartColumn(mytoken( var)->begcol);
  vardclr.SetEndColumn(mytoken( var)->endcol);
  vardclr.SetStartLine(mytoken( var)->getLine());
  vardclr.SetHighlightStartColumn(mytoken( var)->begcol);
  vardclr.SetHighlightStartLine(mytoken( var)->getLine());
  // Well, maybe the StartLine and EndLine might not
  // be on the same line.
  vardclr.SetHighlightEndLine(mytoken( var)->getLine());
  vardclr.SetHighlightEndColumn(mytoken( var)->endcol);
  }
 consume();
  {
    if ( (setwd8[LA(1)]&0x10) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  if ( !guessing ) {
  vardclr.SetType(SN_MBR_VAR_DEF); vardclr.WriteData();}
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd8, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::expression(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==QUAL) ) {
      zzmatch_wsig(QUAL, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==LIT_STRING) ) {
      zzmatch_wsig(LIT_STRING, _handler); consume();
    }
    else {
      if ( (LA(1)==P_DOLLAR) ) {
        var_ref(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==L_SQUARE) ) {
          embedded_command(&_signal); if (_signal) goto _handler;
        }
        else {
          if ( (LA(1)==IDENT3) ) {
            zzmatch_wsig(IDENT3, _handler); consume();
          }
          else {
            if ( (setwd8[LA(1)]&0x40) ) {
              zzsetmatch_wsig(NUMBER_set, _handler); consume();
            }
            else {
              if ( (LA(1)==FILENAME) ) {
                zzmatch_wsig(FILENAME, _handler); consume();
              }
              else {
                if ( (setwd8[LA(1)]&0x80) ) {
                  {
                    while ( (LA(1)==QUAL_IDENT) ) {
                      zzmatch_wsig(QUAL_IDENT, _handler); consume();
                    }
                  }
                  zzsetmatch_wsig(IDENT_set, _handler); consume();
                }
                else {
                  if ( (LA(1)==L_CURLY) ) {
                    tcl_list(&_signal); if (_signal) goto _handler;
                  }
                  else {
                    if ( (setwd9[LA(1)]&0x1) ) {
                      math_expression(&_signal); if (_signal) goto _handler;
                    }
                    else {
                      if ( guessing ) goto fail;
                      if (_sva) _signal=NoViableAlt;
                      else _signal=NoSemViableAlt;
                      goto _handler;  /* MR7 */
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
    if ( (LA(1)==L_BRACKET) ) {
      array_index(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd9, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::l_expression(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==QUAL) ) {
      zzmatch_wsig(QUAL, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==P_DOLLAR) ) {
      var_ref(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_SQUARE) ) {
        embedded_command(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (setwd9[LA(1)]&0x4) ) {
          {
            while ( (LA(1)==QUAL_IDENT) ) {
              zzmatch_wsig(QUAL_IDENT, _handler); consume();
            }
          }
          zzsetmatch_wsig(IDENT_set, _handler); consume();
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  {
    if ( (LA(1)==L_BRACKET) ) {
      array_index(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd9, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::embedded_command(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(L_SQUARE, _handler); consume();
  {
    for (;;) {
      if ( !((setwd9[LA(1)]&0x10))) break;
      if ( (setwd9[LA(1)]&0x20) ) {
        stmt(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
        else break; /* MR6 code for exiting loop "for sure" */
      }
    }
  }
  zzmatch_wsig(R_SQUARE, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd9, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::var_ref(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_DOLLAR, _handler); consume();
  {
    if ( (setwd9[LA(1)]&0x80) ) {
      qual_ident(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        zzmatch_wsig(L_CURLY, _handler); consume();
        qual_ident(&_signal); if (_signal) goto _handler;
        zzmatch_wsig(R_CURLY, _handler); consume();
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd10, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::tcl_list(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(L_CURLY, _handler); consume();
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  {
    while ( (setwd10[LA(1)]&0x2) ) {
      {
        zzGUESS_BLOCK
        zzGUESS
        if ( !zzrv && (LA(1)==L_CURLY) ) {
          {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
          zzGUESS_DONE
          {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
        }
        else {
          if ( !zzrv ) zzGUESS_DONE;
          if ( (setwd10[LA(1)]&0x4) ) {
            expression(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( !zzrv ) zzGUESS_DONE;
            if ( (setwd10[LA(1)]&0x8) ) {
              sub_expression(&_signal); if (_signal) goto _handler;
            }
            else {
              if ( guessing ) goto fail;
              if (_sva) _signal=NoViableAlt;
              else _signal=NoSemViableAlt;
              goto _handler;  /* MR7 */
            }
          }
        }
      }
      {
        while ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
      }
    }
  }
  zzmatch_wsig(R_CURLY, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd10, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::array_index(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(L_BRACKET, _handler); consume();
  {
    int zzcnt=1;
    do {
      expression(&_signal); if (_signal) goto _handler;
    } while ( (setwd10[LA(1)]&0x20) );
  }
  zzmatch_wsig(R_BRACKET, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd10, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

TCLParser::_rv37
TCLParser::qual_ident(int *_retsignal)
{
  struct _rv37 _retv;
  zzRULE;
  int _sva=1;
  ANTLRTokenPtr idA=NULL, idB=NULL;
  int _signal=NoSignal;
  PCCTS_PURIFY(_retv,sizeof(struct _rv37))
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==QUAL) ) {
      zzmatch_wsig(QUAL, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    while ( (LA(1)==QUAL_IDENT) ) {
      zzmatch_wsig(QUAL_IDENT, _handler);
      if ( !guessing ) {
            idA = (ANTLRTokenPtr)LT(1);
      }
      
      if ( !guessing ) {
      _retv.qual = strdup( idA->getText());
      }
 consume();
    }
  }
  zzsetmatch_wsig(IDENT_set, _handler);
  if ( !guessing ) {
    idB = (ANTLRTokenPtr)LT(1);
  }
  
  if ( !guessing ) {
  
  _retv.ident = strdup( idB->getText());
  _retv.start = mytoken( idB)->begcol - 1;
  _retv.end = mytoken( idB)->endcol;
  _retv.line = mytoken( idB)->getLine();
  }
 consume();
  return _retv;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd10, 0x80);
  return _retv;
_handler:
  zzdflthandlers(_signal,_retsignal);
  return _retv;
}

void
TCLParser::other_stmts(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  if ( (LA(1)==P_SET) ) {
    set_stmt(&_signal); if (_signal) goto _handler;
  }
  else {
    if ( (LA(1)==P_UNSET) ) {
      unset_stmt(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==P_LLENGTH) ) {
        llength_stmt(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==P_LAPPEND) ) {
          lappend_stmt(&_signal); if (_signal) goto _handler;
        }
        else {
          if ( (LA(1)==P_LINSERT) ) {
            linsert_stmt(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( (LA(1)==P_LIST) ) {
              list_stmt(&_signal); if (_signal) goto _handler;
            }
            else {
              if ( (LA(1)==P_RETURN) ) {
                return_stmt(&_signal); if (_signal) goto _handler;
              }
              else {
                if ( (LA(1)==P_GLOBLAL) ) {
                  global_stmt(&_signal); if (_signal) goto _handler;
                }
                else {
                  if ( (LA(1)==P_EXPR) ) {
                    expr_stmt(&_signal); if (_signal) goto _handler;
                  }
                  else {
                    if ( (LA(1)==P_PUTS) ) {
                      puts_stmt(&_signal); if (_signal) goto _handler;
                    }
                    else {
                      if ( (setwd11[LA(1)]&0x1) ) {
                        proc_call(&_signal); if (_signal) goto _handler;
                      }
                      else {
                        if ( (LA(1)==P_COMMENT) ) {
                          comment_stmt(&_signal); if (_signal) goto _handler;
                        }
                        else {
                          if ( (LA(1)==P_IF) ) {
                            if_stmt(&_signal); if (_signal) goto _handler;
                          }
                          else {
                            if ( (LA(1)==P_SWITCH) ) {
                              switch_stmt(&_signal); if (_signal) goto _handler;
                            }
                            else {
                              if ( (LA(1)==P_FOREACH) ) {
                                foreach_stmt(&_signal); if (_signal) goto _handler;
                              }
                              else {
                                if ( (LA(1)==P_FOR) ) {
                                  for_stmt(&_signal); if (_signal) goto _handler;
                                }
                                else {
                                  if ( (setwd11[LA(1)]&0x2) ) {
                                    uplevel_stmt(&_signal); if (_signal) goto _handler;
                                  }
                                  else {
                                    if ( (LA(1)==P_CATCH) ) {
                                      catch_stmt(&_signal); if (_signal) goto _handler;
                                    }
                                    else {
                                      if ( (LA(1)==P_WHILE) ) {
                                        while_stmt(&_signal); if (_signal) goto _handler;
                                      }
                                      else {
                                        if ( (LA(1)==P_NAMESPACE) ) {
                                          namespace_stmt(&_signal); if (_signal) goto _handler;
                                        }
                                        else {
                                          if ( (LA(1)==P_BIND) ) {
                                            bind_stmt(&_signal); if (_signal) goto _handler;
                                          }
                                          else {
                                            if ( (LA(1)==P_BODY) ) {
                                              body_stmt(&_signal); if (_signal) goto _handler;
                                            }
                                            else {
                                              if ( (LA(1)==P_SEMI) ) {
                                                zzmatch_wsig(P_SEMI, _handler); consume();
                                              }
                                              else {
                                                if ( guessing ) goto fail;
                                                if (_sva) _signal=NoViableAlt;
                                                else _signal=NoSemViableAlt;
                                                goto _handler;  /* MR7 */
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd11, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::rest_of_line(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    while ( (setwd11[LA(1)]&0x8) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
  }
  {
    if ( (LA(1)==119) ) {
      zzmatch_wsig(119,_handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  zzmatch_wsig(NEW_LINE, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd11, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::set_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_SET, _handler); consume();
  l_expression(&_signal); if (_signal) goto _handler;
  {
    while ( (setwd11[LA(1)]&0x20) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd11, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::unset_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_UNSET, _handler); consume();
  l_expression(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd11, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::bind_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_BIND, _handler); consume();
  expression(&_signal); if (_signal) goto _handler;
  {
    if ( (LA(1)==BIND_EVENT) ) {
      zzmatch_wsig(BIND_EVENT, _handler); consume();
      {
        if ( (setwd12[LA(1)]&0x1) ) {
          {
            if ( (LA(1)==P_ADD) ) {
              zzmatch_wsig(P_ADD, _handler); consume();
            }
            /* MR23 skip error clause for {...} when exceptions in use */
          }
          {
            if ( (LA(1)==L_CURLY) ) {
              stmt_block(&_signal); if (_signal) goto _handler;
            }
            else {
              if ( (LA(1)==LIT_STRING) ) {
                zzmatch_wsig(LIT_STRING, _handler); consume();
              }
              else {
                if ( guessing ) goto fail;
                if (_sva) _signal=NoViableAlt;
                else _signal=NoSemViableAlt;
                goto _handler;  /* MR7 */
              }
            }
          }
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd12, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::source_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_SOURCE, _handler); consume();
  expression(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd12, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::lappend_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_LAPPEND, _handler); consume();
  {
    if ( (setwd12[LA(1)]&0x8) ) {
      l_expression(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        tcl_list(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    while ( (setwd12[LA(1)]&0x10) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd12, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::llength_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_LLENGTH, _handler); consume();
  {
    if ( (setwd12[LA(1)]&0x40) ) {
      l_expression(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        tcl_list(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd12, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::linsert_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_LINSERT, _handler); consume();
  {
    if ( (setwd13[LA(1)]&0x1) ) {
      l_expression(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        tcl_list(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    if ( (setwd13[LA(1)]&0x2) ) {
      zzsetmatch_wsig(NUMBER_set, _handler); consume();
    }
    else {
      if ( (setwd13[LA(1)]&0x4) ) {
        l_expression(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    int zzcnt=1;
    do {
      expression(&_signal); if (_signal) goto _handler;
    } while ( (setwd13[LA(1)]&0x8) );
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd13, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::list_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_LIST, _handler); consume();
  {
    while ( (setwd13[LA(1)]&0x20) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd13, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::info_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_INFO, _handler); consume();
  zzsetmatch_wsig(IDENT_set, _handler); consume();
  rest_of_line(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd13, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::uplevel_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==P_UPLEVEL) ) {
      zzmatch_wsig(P_UPLEVEL, _handler); consume();
    }
    else {
      if ( (LA(1)==P_UPLEVEL_ABS) ) {
        zzmatch_wsig(P_UPLEVEL_ABS, _handler); consume();
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  zzsetmatch_wsig(NUMBER_set, _handler); consume();
  {
    if ( (setwd14[LA(1)]&0x1) ) {
      stmt(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        stmt_block(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (LA(1)==LIT_STRING) ) {
          zzmatch_wsig(LIT_STRING, _handler); consume();
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd14, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::global_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_GLOBLAL, _handler); consume();
  {
    while ( (setwd14[LA(1)]&0x4) ) {
      zzsetmatch_wsig(IDENT_set, _handler); consume();
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd14, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::return_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_RETURN, _handler); consume();
  {
    if ( (setwd14[LA(1)]&0x10) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd14, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::puts_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_PUTS, _handler); consume();
  {
    if ( (LA(1)==P_NONEWLINE) ) {
      zzmatch_wsig(P_NONEWLINE, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    while ( (setwd14[LA(1)]&0x40) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd14, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::comment_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_COMMENT, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd15, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::catch_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_CATCH, _handler); consume();
  {
    zzGUESS_BLOCK
    zzGUESS
    if ( !zzrv && (LA(1)==L_CURLY) ) {
      {
        stmt_block(&_signal); if (_signal) goto _handler;
      }
      zzGUESS_DONE
      {
        stmt_block(&_signal); if (_signal) goto _handler;
      }
    }
    else {
      if ( !zzrv ) zzGUESS_DONE;
      if ( (setwd15[LA(1)]&0x2) ) {
        expression(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    if ( (setwd15[LA(1)]&0x4) ) {
      qual_ident(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd15, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::if_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_IF, _handler); consume();
  {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      cond_expression(&_signal); if (_signal) goto _handler;
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( (setwd15[LA(1)]&0x10) ) {
        expression(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    if ( (LA(1)==P_THEN) ) {
      zzmatch_wsig(P_THEN, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==L_CURLY) ) {
      stmt_block(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (setwd15[LA(1)]&0x20) ) {
        stmt(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    while ( (LA(1)==P_ELSEIF) ) {
      elseif_stmt(&_signal); if (_signal) goto _handler;
    }
  }
  {
    if ( (LA(1)==P_ELSE) ) {
      else_stmt(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd15, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::cond_expression(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  sub_cond_expression(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd15, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::cond_expression2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (setwd16[LA(1)]&0x1) ) {
      expression(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (setwd16[LA(1)]&0x2) ) {
        zzsetmatch_wsig(LVALUE_set, _handler); consume();
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd16, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::sub_cond_expression(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  {
    if ( (LA(1)==P_NOT) ) {
      zzmatch_wsig(P_NOT, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  {
    if ( (LA(1)==L_BRACKET) ) {
      zzmatch_wsig(L_BRACKET, _handler); consume();
      {
        while ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
      }
      sub_cond_expression(&_signal); if (_signal) goto _handler;
      {
        while ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
      }
      zzmatch_wsig(R_BRACKET, _handler); consume();
      {
        while ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
      }
      {
        while ( (setwd16[LA(1)]&0x8) ) {
          {
            if ( (setwd16[LA(1)]&0x10) ) {
              zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
            }
            /* MR23 skip error clause for {...} when exceptions in use */
          }
          sub_cond_expression(&_signal); if (_signal) goto _handler;
        }
      }
    }
    else {
      if ( (setwd16[LA(1)]&0x20) ) {
        cond_expression2(&_signal); if (_signal) goto _handler;
        {
          while ( (LA(1)==NEW_LINE) ) {
            zzmatch_wsig(NEW_LINE, _handler); consume();
          }
        }
        {
          while ( (setwd16[LA(1)]&0x40) ) {
            {
              if ( (setwd16[LA(1)]&0x80) ) {
                zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
              }
              /* MR23 skip error clause for {...} when exceptions in use */
            }
            sub_cond_expression(&_signal); if (_signal) goto _handler;
          }
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd17, 0x1);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::elseif_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_ELSEIF, _handler); consume();
  {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      cond_expression(&_signal); if (_signal) goto _handler;
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( (setwd17[LA(1)]&0x2) ) {
        expression(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    if ( (LA(1)==P_THEN) ) {
      zzmatch_wsig(P_THEN, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    if ( (LA(1)==L_CURLY) ) {
      stmt_block(&_signal); if (_signal) goto _handler;
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd17, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::else_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_ELSE, _handler); consume();
  stmt_block(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd17, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::switch_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_SWITCH, _handler); consume();
  {
    if ( (LA(1)==P_DASHGLOB) ) {
      zzmatch_wsig(P_DASHGLOB, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  expression(&_signal); if (_signal) goto _handler;
  {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      switch_body2(&_signal); if (_signal) goto _handler;
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( (setwd17[LA(1)]&0x10) ) {
        {
          int zzcnt=1;
          do {
            switch_case(&_signal); if (_signal) goto _handler;
          } while ( (setwd17[LA(1)]&0x20) );
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd17, 0x40);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::switch_case(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  expression(&_signal); if (_signal) goto _handler;
  {
    if ( (LA(1)==P_SUBTRACT) ) {
      zzmatch_wsig(P_SUBTRACT, _handler); consume();
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        stmt_block(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd17, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::switch_body2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    while ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
  }
  {
    int zzcnt=1;
    do {
      switch_case(&_signal); if (_signal) goto _handler;
      {
        while ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
      }
    } while ( (setwd18[LA(1)]&0x1) );
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd18, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::foreach_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_FOREACH, _handler); consume();
  {
    if ( (setwd18[LA(1)]&0x4) ) {
      l_expression(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        tcl_list(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  expression(&_signal); if (_signal) goto _handler;
  {
    zzGUESS_BLOCK
    zzGUESS
    if ( !zzrv && (setwd18[LA(1)]&0x8) ) {
      {
        {
          while ( (setwd18[LA(1)]&0x10) ) {
            {
              if ( (setwd18[LA(1)]&0x20) ) {
                l_expression(&_signal); if (_signal) goto _handler;
              }
              else {
                if ( (LA(1)==L_CURLY) ) {
                  tcl_list(&_signal); if (_signal) goto _handler;
                }
                else {
                  if ( guessing ) goto fail;
                  if (_sva) _signal=NoViableAlt;
                  else _signal=NoSemViableAlt;
                  goto _handler;  /* MR7 */
                }
              }
            }
            expression(&_signal); if (_signal) goto _handler;
          }
        }
        {
          if ( (LA(1)==L_CURLY) ) {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( (setwd18[LA(1)]&0x40) ) {
              stmt(&_signal); if (_signal) goto _handler;
            }
            else {
              if ( guessing ) goto fail;
              if (_sva) _signal=NoViableAlt;
              else _signal=NoSemViableAlt;
              goto _handler;  /* MR7 */
            }
          }
        }
      }
      zzGUESS_DONE
      {
        {
          while ( (setwd18[LA(1)]&0x80) ) {
            {
              if ( (setwd19[LA(1)]&0x1) ) {
                l_expression(&_signal); if (_signal) goto _handler;
              }
              else {
                if ( (LA(1)==L_CURLY) ) {
                  tcl_list(&_signal); if (_signal) goto _handler;
                }
                else {
                  if ( guessing ) goto fail;
                  if (_sva) _signal=NoViableAlt;
                  else _signal=NoSemViableAlt;
                  goto _handler;  /* MR7 */
                }
              }
            }
            expression(&_signal); if (_signal) goto _handler;
          }
        }
        {
          if ( (LA(1)==L_CURLY) ) {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( (setwd19[LA(1)]&0x2) ) {
              stmt(&_signal); if (_signal) goto _handler;
            }
            else {
              if ( guessing ) goto fail;
              if (_sva) _signal=NoViableAlt;
              else _signal=NoSemViableAlt;
              goto _handler;  /* MR7 */
            }
          }
        }
      }
    }
    else {
      if ( !zzrv ) zzGUESS_DONE;
      if ( (setwd19[LA(1)]&0x4) ) {
        {
          if ( (LA(1)==L_CURLY) ) {
            stmt_block(&_signal); if (_signal) goto _handler;
          }
          else {
            if ( (setwd19[LA(1)]&0x8) ) {
              stmt(&_signal); if (_signal) goto _handler;
            }
            else {
              if ( guessing ) goto fail;
              if (_sva) _signal=NoViableAlt;
              else _signal=NoSemViableAlt;
              goto _handler;  /* MR7 */
            }
          }
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd19, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::for_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_FOR, _handler); consume();
  stmt_block(&_signal); if (_signal) goto _handler;
  zzmatch_wsig(L_CURLY, _handler); consume();
  cond_expression(&_signal); if (_signal) goto _handler;
  zzmatch_wsig(R_CURLY, _handler); consume();
  stmt_block(&_signal); if (_signal) goto _handler;
  stmt_block(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd19, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::while_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_WHILE, _handler); consume();
  {
    if ( (LA(1)==L_CURLY) ) {
      zzmatch_wsig(L_CURLY, _handler); consume();
      cond_expression(&_signal); if (_signal) goto _handler;
      zzmatch_wsig(R_CURLY, _handler); consume();
    }
    else {
      if ( (setwd19[LA(1)]&0x40) ) {
        expression(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  stmt_block(&_signal); if (_signal) goto _handler;
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd19, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::expr_stmt(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzmatch_wsig(P_EXPR, _handler); consume();
  {
    if ( (setwd20[LA(1)]&0x1) ) {
      sub_expression(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (LA(1)==L_CURLY) ) {
        zzmatch_wsig(L_CURLY, _handler); consume();
        {
          if ( (LA(1)==NEW_LINE) ) {
            zzmatch_wsig(NEW_LINE, _handler); consume();
          }
          /* MR23 skip error clause for {...} when exceptions in use */
        }
        sub_expression2(&_signal); if (_signal) goto _handler;
        {
          while ( (setwd20[LA(1)]&0x2) ) {
            {
              if ( (setwd20[LA(1)]&0x4) ) {
                zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
              }
              /* MR23 skip error clause for {...} when exceptions in use */
            }
            {
              if ( (LA(1)==NEW_LINE) ) {
                zzmatch_wsig(NEW_LINE, _handler); consume();
              }
              /* MR23 skip error clause for {...} when exceptions in use */
            }
            sub_expression2(&_signal); if (_signal) goto _handler;
          }
        }
        zzmatch_wsig(R_CURLY, _handler); consume();
      }
      else {
        if ( (LA(1)==LIT_STRING) ) {
          zzmatch_wsig(LIT_STRING, _handler); consume();
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd20, 0x8);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::sub_expression(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==L_BRACKET) ) {
      zzmatch_wsig(L_BRACKET, _handler); consume();
      {
        if ( (setwd20[LA(1)]&0x10) ) {
          sub_expression(&_signal); if (_signal) goto _handler;
          {
            while ( (setwd20[LA(1)]&0x20) ) {
              {
                if ( (setwd20[LA(1)]&0x40) ) {
                  zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
                }
                /* MR23 skip error clause for {...} when exceptions in use */
              }
              sub_expression(&_signal); if (_signal) goto _handler;
            }
          }
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
      zzmatch_wsig(R_BRACKET, _handler); consume();
    }
    else {
      if ( (setwd20[LA(1)]&0x80) ) {
        math_expression(&_signal); if (_signal) goto _handler;
        {
          while ( (setwd21[LA(1)]&0x1) ) {
            {
              if ( (setwd21[LA(1)]&0x2) ) {
                zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
              }
              /* MR23 skip error clause for {...} when exceptions in use */
            }
            sub_expression(&_signal); if (_signal) goto _handler;
          }
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd21, 0x4);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::math_expression(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  if ( (LA(1)==P_DOLLAR) ) {
    var_ref(&_signal); if (_signal) goto _handler;
    {
      if ( (LA(1)==L_BRACKET) ) {
        array_index(&_signal); if (_signal) goto _handler;
      }
      /* MR23 skip error clause for {...} when exceptions in use */
    }
  }
  else {
    if ( (LA(1)==L_SQUARE) ) {
      embedded_command(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (setwd21[LA(1)]&0x8) ) {
        zzsetmatch_wsig(LVALUE_set, _handler); consume();
      }
      else {
        if ( (setwd21[LA(1)]&0x10) ) {
          math_function(&_signal); if (_signal) goto _handler;
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd21, 0x20);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::math_function(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzsetmatch_wsig(IDENT_set, _handler); consume();
  zzmatch_wsig(L_BRACKET, _handler); consume();
  {
    while ( (setwd21[LA(1)]&0x40) ) {
      sub_expression(&_signal); if (_signal) goto _handler;
    }
  }
  zzmatch_wsig(R_BRACKET, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd21, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::sub_expression2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  {
    if ( (LA(1)==L_BRACKET) ) {
      zzmatch_wsig(L_BRACKET, _handler); consume();
      {
        if ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
      sub_expression2(&_signal); if (_signal) goto _handler;
      {
        while ( (setwd22[LA(1)]&0x1) ) {
          {
            if ( (setwd22[LA(1)]&0x2) ) {
              zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
            }
            /* MR23 skip error clause for {...} when exceptions in use */
          }
          {
            if ( (LA(1)==NEW_LINE) ) {
              zzmatch_wsig(NEW_LINE, _handler); consume();
            }
            /* MR23 skip error clause for {...} when exceptions in use */
          }
          sub_expression2(&_signal); if (_signal) goto _handler;
        }
      }
      zzmatch_wsig(R_BRACKET, _handler); consume();
      {
        if ( (LA(1)==NEW_LINE) ) {
          zzmatch_wsig(NEW_LINE, _handler); consume();
        }
        /* MR23 skip error clause for {...} when exceptions in use */
      }
    }
    else {
      if ( (setwd22[LA(1)]&0x4) ) {
        math_expression2(&_signal); if (_signal) goto _handler;
        {
          if ( (LA(1)==NEW_LINE) ) {
            zzmatch_wsig(NEW_LINE, _handler); consume();
          }
          /* MR23 skip error clause for {...} when exceptions in use */
        }
        {
          while ( (setwd22[LA(1)]&0x8) ) {
            zzsetmatch_wsig(P_OPERATORS_set, _handler); consume();
            {
              if ( (LA(1)==NEW_LINE) ) {
                zzmatch_wsig(NEW_LINE, _handler); consume();
              }
              /* MR23 skip error clause for {...} when exceptions in use */
            }
            sub_expression2(&_signal); if (_signal) goto _handler;
          }
        }
      }
      else {
        if ( guessing ) goto fail;
        if (_sva) _signal=NoViableAlt;
        else _signal=NoSemViableAlt;
        goto _handler;  /* MR7 */
      }
    }
  }
  {
    if ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd22, 0x10);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::math_expression2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  if ( (LA(1)==P_DOLLAR) ) {
    var_ref(&_signal); if (_signal) goto _handler;
    {
      if ( (LA(1)==L_BRACKET) ) {
        array_index(&_signal); if (_signal) goto _handler;
      }
      /* MR23 skip error clause for {...} when exceptions in use */
    }
  }
  else {
    if ( (LA(1)==L_SQUARE) ) {
      embedded_command(&_signal); if (_signal) goto _handler;
    }
    else {
      if ( (setwd22[LA(1)]&0x20) ) {
        math_function2(&_signal); if (_signal) goto _handler;
      }
      else {
        if ( (setwd22[LA(1)]&0x40) ) {
          zzsetmatch_wsig(LVALUE_set, _handler); consume();
        }
        else {
          if ( guessing ) goto fail;
          if (_sva) _signal=NoViableAlt;
          else _signal=NoSemViableAlt;
          goto _handler;  /* MR7 */
        }
      }
    }
  }
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd22, 0x80);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}

void
TCLParser::math_function2(int *_retsignal)
{
  zzRULE;
  int _sva=1;
  int _signal=NoSignal;
  *_retsignal = NoSignal;
  zzsetmatch_wsig(IDENT_set, _handler); consume();
  {
    if ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  zzmatch_wsig(L_BRACKET, _handler); consume();
  {
    if ( (LA(1)==NEW_LINE) ) {
      zzmatch_wsig(NEW_LINE, _handler); consume();
    }
    /* MR23 skip error clause for {...} when exceptions in use */
  }
  {
    while ( (setwd23[LA(1)]&0x1) ) {
      sub_expression2(&_signal); if (_signal) goto _handler;
    }
  }
  zzmatch_wsig(R_BRACKET, _handler); consume();
  return;
fail:
  if ( guessing ) zzGUESS_FAIL;
  syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
  resynch(setwd23, 0x2);
_handler:
  zzdflthandlers(_signal,_retsignal);
  return;
}
